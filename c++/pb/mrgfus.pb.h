// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mrgfus.proto

#ifndef PROTOBUF_mrgfus_2eproto__INCLUDED
#define PROTOBUF_mrgfus_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3001000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3001000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_mrgfus_2eproto();
void protobuf_InitDefaults_mrgfus_2eproto();
void protobuf_AssignDesc_mrgfus_2eproto();
void protobuf_ShutdownFile_mrgfus_2eproto();

class AutoScanPb;
class GRESeq;
class ImgXferPb;
class MRStatusNotifyPb;
class MRStatusQueryPb;
class MRgFUSPb;
class ManuScanPb;
class SESeq;

enum MRStatusQueryPb_MRStatus {
  MRStatusQueryPb_MRStatus_NORMAL = 1,
  MRStatusQueryPb_MRStatus_ABNORMAL = 2
};
bool MRStatusQueryPb_MRStatus_IsValid(int value);
const MRStatusQueryPb_MRStatus MRStatusQueryPb_MRStatus_MRStatus_MIN = MRStatusQueryPb_MRStatus_NORMAL;
const MRStatusQueryPb_MRStatus MRStatusQueryPb_MRStatus_MRStatus_MAX = MRStatusQueryPb_MRStatus_ABNORMAL;
const int MRStatusQueryPb_MRStatus_MRStatus_ARRAYSIZE = MRStatusQueryPb_MRStatus_MRStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* MRStatusQueryPb_MRStatus_descriptor();
inline const ::std::string& MRStatusQueryPb_MRStatus_Name(MRStatusQueryPb_MRStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    MRStatusQueryPb_MRStatus_descriptor(), value);
}
inline bool MRStatusQueryPb_MRStatus_Parse(
    const ::std::string& name, MRStatusQueryPb_MRStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MRStatusQueryPb_MRStatus>(
    MRStatusQueryPb_MRStatus_descriptor(), name, value);
}
enum MRStatusNotifyPb_MRStatus {
  MRStatusNotifyPb_MRStatus_ABNORMAL = 1,
  MRStatusNotifyPb_MRStatus_SCAN_INTERRUPT = 2
};
bool MRStatusNotifyPb_MRStatus_IsValid(int value);
const MRStatusNotifyPb_MRStatus MRStatusNotifyPb_MRStatus_MRStatus_MIN = MRStatusNotifyPb_MRStatus_ABNORMAL;
const MRStatusNotifyPb_MRStatus MRStatusNotifyPb_MRStatus_MRStatus_MAX = MRStatusNotifyPb_MRStatus_SCAN_INTERRUPT;
const int MRStatusNotifyPb_MRStatus_MRStatus_ARRAYSIZE = MRStatusNotifyPb_MRStatus_MRStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* MRStatusNotifyPb_MRStatus_descriptor();
inline const ::std::string& MRStatusNotifyPb_MRStatus_Name(MRStatusNotifyPb_MRStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    MRStatusNotifyPb_MRStatus_descriptor(), value);
}
inline bool MRStatusNotifyPb_MRStatus_Parse(
    const ::std::string& name, MRStatusNotifyPb_MRStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MRStatusNotifyPb_MRStatus>(
    MRStatusNotifyPb_MRStatus_descriptor(), name, value);
}
enum ImgXferPb_ImageType {
  ImgXferPb_ImageType_NON_THERM = 1,
  ImgXferPb_ImageType_THERM = 2
};
bool ImgXferPb_ImageType_IsValid(int value);
const ImgXferPb_ImageType ImgXferPb_ImageType_ImageType_MIN = ImgXferPb_ImageType_NON_THERM;
const ImgXferPb_ImageType ImgXferPb_ImageType_ImageType_MAX = ImgXferPb_ImageType_THERM;
const int ImgXferPb_ImageType_ImageType_ARRAYSIZE = ImgXferPb_ImageType_ImageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ImgXferPb_ImageType_descriptor();
inline const ::std::string& ImgXferPb_ImageType_Name(ImgXferPb_ImageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ImgXferPb_ImageType_descriptor(), value);
}
inline bool ImgXferPb_ImageType_Parse(
    const ::std::string& name, ImgXferPb_ImageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ImgXferPb_ImageType>(
    ImgXferPb_ImageType_descriptor(), name, value);
}
enum MRgFUSPb_ProtoCateg {
  MRgFUSPb_ProtoCateg_MR_STATUS_QUERY = 1,
  MRgFUSPb_ProtoCateg_MR_STATUS_NOTIFY = 2,
  MRgFUSPb_ProtoCateg_MANU_SCAN = 3,
  MRgFUSPb_ProtoCateg_AUTO_SCAN = 4,
  MRgFUSPb_ProtoCateg_IMG_XFER = 5
};
bool MRgFUSPb_ProtoCateg_IsValid(int value);
const MRgFUSPb_ProtoCateg MRgFUSPb_ProtoCateg_ProtoCateg_MIN = MRgFUSPb_ProtoCateg_MR_STATUS_QUERY;
const MRgFUSPb_ProtoCateg MRgFUSPb_ProtoCateg_ProtoCateg_MAX = MRgFUSPb_ProtoCateg_IMG_XFER;
const int MRgFUSPb_ProtoCateg_ProtoCateg_ARRAYSIZE = MRgFUSPb_ProtoCateg_ProtoCateg_MAX + 1;

const ::google::protobuf::EnumDescriptor* MRgFUSPb_ProtoCateg_descriptor();
inline const ::std::string& MRgFUSPb_ProtoCateg_Name(MRgFUSPb_ProtoCateg value) {
  return ::google::protobuf::internal::NameOfEnum(
    MRgFUSPb_ProtoCateg_descriptor(), value);
}
inline bool MRgFUSPb_ProtoCateg_Parse(
    const ::std::string& name, MRgFUSPb_ProtoCateg* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MRgFUSPb_ProtoCateg>(
    MRgFUSPb_ProtoCateg_descriptor(), name, value);
}
enum MsgType {
  REQ = 1,
  RSP = 2
};
bool MsgType_IsValid(int value);
const MsgType MsgType_MIN = REQ;
const MsgType MsgType_MAX = RSP;
const int MsgType_ARRAYSIZE = MsgType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MsgType_descriptor();
inline const ::std::string& MsgType_Name(MsgType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgType_descriptor(), value);
}
inline bool MsgType_Parse(
    const ::std::string& name, MsgType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgType>(
    MsgType_descriptor(), name, value);
}
enum ExecResult {
  SUCCESS = 1,
  FAIL = 2
};
bool ExecResult_IsValid(int value);
const ExecResult ExecResult_MIN = SUCCESS;
const ExecResult ExecResult_MAX = FAIL;
const int ExecResult_ARRAYSIZE = ExecResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* ExecResult_descriptor();
inline const ::std::string& ExecResult_Name(ExecResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    ExecResult_descriptor(), value);
}
inline bool ExecResult_Parse(
    const ::std::string& name, ExecResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExecResult>(
    ExecResult_descriptor(), name, value);
}
enum SeqType {
  SE = 1,
  GRE = 2
};
bool SeqType_IsValid(int value);
const SeqType SeqType_MIN = SE;
const SeqType SeqType_MAX = GRE;
const int SeqType_ARRAYSIZE = SeqType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SeqType_descriptor();
inline const ::std::string& SeqType_Name(SeqType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SeqType_descriptor(), value);
}
inline bool SeqType_Parse(
    const ::std::string& name, SeqType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SeqType>(
    SeqType_descriptor(), name, value);
}
enum ScanOrient {
  AXIAL = 1,
  SAGITAL = 2,
  CORONAL = 3,
  OBLIQUE = 4
};
bool ScanOrient_IsValid(int value);
const ScanOrient ScanOrient_MIN = AXIAL;
const ScanOrient ScanOrient_MAX = OBLIQUE;
const int ScanOrient_ARRAYSIZE = ScanOrient_MAX + 1;

const ::google::protobuf::EnumDescriptor* ScanOrient_descriptor();
inline const ::std::string& ScanOrient_Name(ScanOrient value) {
  return ::google::protobuf::internal::NameOfEnum(
    ScanOrient_descriptor(), value);
}
inline bool ScanOrient_Parse(
    const ::std::string& name, ScanOrient* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ScanOrient>(
    ScanOrient_descriptor(), name, value);
}
enum FreqDirection {
  LR = 1,
  AP = 2,
  IS = 3
};
bool FreqDirection_IsValid(int value);
const FreqDirection FreqDirection_MIN = LR;
const FreqDirection FreqDirection_MAX = IS;
const int FreqDirection_ARRAYSIZE = FreqDirection_MAX + 1;

const ::google::protobuf::EnumDescriptor* FreqDirection_descriptor();
inline const ::std::string& FreqDirection_Name(FreqDirection value) {
  return ::google::protobuf::internal::NameOfEnum(
    FreqDirection_descriptor(), value);
}
inline bool FreqDirection_Parse(
    const ::std::string& name, FreqDirection* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FreqDirection>(
    FreqDirection_descriptor(), name, value);
}
// ===================================================================

class SESeq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SESeq) */ {
 public:
  SESeq();
  virtual ~SESeq();

  SESeq(const SESeq& from);

  inline SESeq& operator=(const SESeq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SESeq& default_instance();

  static const SESeq* internal_default_instance();

  void Swap(SESeq* other);

  // implements Message ----------------------------------------------

  inline SESeq* New() const { return New(NULL); }

  SESeq* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SESeq& from);
  void MergeFrom(const SESeq& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SESeq* other);
  void UnsafeMergeFrom(const SESeq& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ScanOrient orientation = 1;
  bool has_orientation() const;
  void clear_orientation();
  static const int kOrientationFieldNumber = 1;
  ::ScanOrient orientation() const;
  void set_orientation(::ScanOrient value);

  // required uint32 fov = 2;
  bool has_fov() const;
  void clear_fov();
  static const int kFovFieldNumber = 2;
  ::google::protobuf::uint32 fov() const;
  void set_fov(::google::protobuf::uint32 value);

  // required double slice_thickness = 3;
  bool has_slice_thickness() const;
  void clear_slice_thickness();
  static const int kSliceThicknessFieldNumber = 3;
  double slice_thickness() const;
  void set_slice_thickness(double value);

  // required double slice_spacing = 4;
  bool has_slice_spacing() const;
  void clear_slice_spacing();
  static const int kSliceSpacingFieldNumber = 4;
  double slice_spacing() const;
  void set_slice_spacing(double value);

  // required double start_rl = 5;
  bool has_start_rl() const;
  void clear_start_rl();
  static const int kStartRlFieldNumber = 5;
  double start_rl() const;
  void set_start_rl(double value);

  // required double start_ap = 6;
  bool has_start_ap() const;
  void clear_start_ap();
  static const int kStartApFieldNumber = 6;
  double start_ap() const;
  void set_start_ap(double value);

  // required double start_is = 7;
  bool has_start_is() const;
  void clear_start_is();
  static const int kStartIsFieldNumber = 7;
  double start_is() const;
  void set_start_is(double value);

  // required double end_rl = 8;
  bool has_end_rl() const;
  void clear_end_rl();
  static const int kEndRlFieldNumber = 8;
  double end_rl() const;
  void set_end_rl(double value);

  // required double end_ap = 9;
  bool has_end_ap() const;
  void clear_end_ap();
  static const int kEndApFieldNumber = 9;
  double end_ap() const;
  void set_end_ap(double value);

  // required double end_is = 10;
  bool has_end_is() const;
  void clear_end_is();
  static const int kEndIsFieldNumber = 10;
  double end_is() const;
  void set_end_is(double value);

  // required uint32 slices = 11;
  bool has_slices() const;
  void clear_slices();
  static const int kSlicesFieldNumber = 11;
  ::google::protobuf::uint32 slices() const;
  void set_slices(::google::protobuf::uint32 value);

  // required uint32 image_height = 12;
  bool has_image_height() const;
  void clear_image_height();
  static const int kImageHeightFieldNumber = 12;
  ::google::protobuf::uint32 image_height() const;
  void set_image_height(::google::protobuf::uint32 value);

  // required uint32 image_width = 13;
  bool has_image_width() const;
  void clear_image_width();
  static const int kImageWidthFieldNumber = 13;
  ::google::protobuf::uint32 image_width() const;
  void set_image_width(::google::protobuf::uint32 value);

  // optional uint32 te = 14;
  bool has_te() const;
  void clear_te();
  static const int kTeFieldNumber = 14;
  ::google::protobuf::uint32 te() const;
  void set_te(::google::protobuf::uint32 value);

  // optional uint32 tr = 15;
  bool has_tr() const;
  void clear_tr();
  static const int kTrFieldNumber = 15;
  ::google::protobuf::uint32 tr() const;
  void set_tr(::google::protobuf::uint32 value);

  // optional uint32 fa = 16;
  bool has_fa() const;
  void clear_fa();
  static const int kFaFieldNumber = 16;
  ::google::protobuf::uint32 fa() const;
  void set_fa(::google::protobuf::uint32 value);

  // optional uint32 freq_encoding = 17;
  bool has_freq_encoding() const;
  void clear_freq_encoding();
  static const int kFreqEncodingFieldNumber = 17;
  ::google::protobuf::uint32 freq_encoding() const;
  void set_freq_encoding(::google::protobuf::uint32 value);

  // optional uint32 phase_encoding = 18;
  bool has_phase_encoding() const;
  void clear_phase_encoding();
  static const int kPhaseEncodingFieldNumber = 18;
  ::google::protobuf::uint32 phase_encoding() const;
  void set_phase_encoding(::google::protobuf::uint32 value);

  // optional double nex = 19;
  bool has_nex() const;
  void clear_nex();
  static const int kNexFieldNumber = 19;
  double nex() const;
  void set_nex(double value);

  // optional double band_width = 20;
  bool has_band_width() const;
  void clear_band_width();
  static const int kBandWidthFieldNumber = 20;
  double band_width() const;
  void set_band_width(double value);

  // optional .FreqDirection freq_dir = 21;
  bool has_freq_dir() const;
  void clear_freq_dir();
  static const int kFreqDirFieldNumber = 21;
  ::FreqDirection freq_dir() const;
  void set_freq_dir(::FreqDirection value);

  // @@protoc_insertion_point(class_scope:SESeq)
 private:
  inline void set_has_orientation();
  inline void clear_has_orientation();
  inline void set_has_fov();
  inline void clear_has_fov();
  inline void set_has_slice_thickness();
  inline void clear_has_slice_thickness();
  inline void set_has_slice_spacing();
  inline void clear_has_slice_spacing();
  inline void set_has_start_rl();
  inline void clear_has_start_rl();
  inline void set_has_start_ap();
  inline void clear_has_start_ap();
  inline void set_has_start_is();
  inline void clear_has_start_is();
  inline void set_has_end_rl();
  inline void clear_has_end_rl();
  inline void set_has_end_ap();
  inline void clear_has_end_ap();
  inline void set_has_end_is();
  inline void clear_has_end_is();
  inline void set_has_slices();
  inline void clear_has_slices();
  inline void set_has_image_height();
  inline void clear_has_image_height();
  inline void set_has_image_width();
  inline void clear_has_image_width();
  inline void set_has_te();
  inline void clear_has_te();
  inline void set_has_tr();
  inline void clear_has_tr();
  inline void set_has_fa();
  inline void clear_has_fa();
  inline void set_has_freq_encoding();
  inline void clear_has_freq_encoding();
  inline void set_has_phase_encoding();
  inline void clear_has_phase_encoding();
  inline void set_has_nex();
  inline void clear_has_nex();
  inline void set_has_band_width();
  inline void clear_has_band_width();
  inline void set_has_freq_dir();
  inline void clear_has_freq_dir();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double slice_thickness_;
  double slice_spacing_;
  double start_rl_;
  double start_ap_;
  ::google::protobuf::uint32 fov_;
  ::google::protobuf::uint32 slices_;
  double start_is_;
  double end_rl_;
  double end_ap_;
  double end_is_;
  ::google::protobuf::uint32 image_height_;
  ::google::protobuf::uint32 image_width_;
  ::google::protobuf::uint32 te_;
  ::google::protobuf::uint32 tr_;
  ::google::protobuf::uint32 fa_;
  ::google::protobuf::uint32 freq_encoding_;
  double nex_;
  double band_width_;
  ::google::protobuf::uint32 phase_encoding_;
  int orientation_;
  int freq_dir_;
  friend void  protobuf_InitDefaults_mrgfus_2eproto_impl();
  friend void  protobuf_AddDesc_mrgfus_2eproto_impl();
  friend void protobuf_AssignDesc_mrgfus_2eproto();
  friend void protobuf_ShutdownFile_mrgfus_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<SESeq> SESeq_default_instance_;

// -------------------------------------------------------------------

class GRESeq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:GRESeq) */ {
 public:
  GRESeq();
  virtual ~GRESeq();

  GRESeq(const GRESeq& from);

  inline GRESeq& operator=(const GRESeq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GRESeq& default_instance();

  static const GRESeq* internal_default_instance();

  void Swap(GRESeq* other);

  // implements Message ----------------------------------------------

  inline GRESeq* New() const { return New(NULL); }

  GRESeq* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GRESeq& from);
  void MergeFrom(const GRESeq& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GRESeq* other);
  void UnsafeMergeFrom(const GRESeq& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool thm_calc = 1;
  bool has_thm_calc() const;
  void clear_thm_calc();
  static const int kThmCalcFieldNumber = 1;
  bool thm_calc() const;
  void set_thm_calc(bool value);

  // required .ScanOrient orientation = 2;
  bool has_orientation() const;
  void clear_orientation();
  static const int kOrientationFieldNumber = 2;
  ::ScanOrient orientation() const;
  void set_orientation(::ScanOrient value);

  // required uint32 fov = 3;
  bool has_fov() const;
  void clear_fov();
  static const int kFovFieldNumber = 3;
  ::google::protobuf::uint32 fov() const;
  void set_fov(::google::protobuf::uint32 value);

  // required double slice_thickness = 4;
  bool has_slice_thickness() const;
  void clear_slice_thickness();
  static const int kSliceThicknessFieldNumber = 4;
  double slice_thickness() const;
  void set_slice_thickness(double value);

  // required double slice_spacing = 5;
  bool has_slice_spacing() const;
  void clear_slice_spacing();
  static const int kSliceSpacingFieldNumber = 5;
  double slice_spacing() const;
  void set_slice_spacing(double value);

  // required double start_rl = 6;
  bool has_start_rl() const;
  void clear_start_rl();
  static const int kStartRlFieldNumber = 6;
  double start_rl() const;
  void set_start_rl(double value);

  // required double start_ap = 7;
  bool has_start_ap() const;
  void clear_start_ap();
  static const int kStartApFieldNumber = 7;
  double start_ap() const;
  void set_start_ap(double value);

  // required double start_is = 8;
  bool has_start_is() const;
  void clear_start_is();
  static const int kStartIsFieldNumber = 8;
  double start_is() const;
  void set_start_is(double value);

  // required double end_rl = 9;
  bool has_end_rl() const;
  void clear_end_rl();
  static const int kEndRlFieldNumber = 9;
  double end_rl() const;
  void set_end_rl(double value);

  // required double end_ap = 10;
  bool has_end_ap() const;
  void clear_end_ap();
  static const int kEndApFieldNumber = 10;
  double end_ap() const;
  void set_end_ap(double value);

  // required double end_is = 11;
  bool has_end_is() const;
  void clear_end_is();
  static const int kEndIsFieldNumber = 11;
  double end_is() const;
  void set_end_is(double value);

  // required uint32 slices = 12;
  bool has_slices() const;
  void clear_slices();
  static const int kSlicesFieldNumber = 12;
  ::google::protobuf::uint32 slices() const;
  void set_slices(::google::protobuf::uint32 value);

  // required uint32 phases = 13;
  bool has_phases() const;
  void clear_phases();
  static const int kPhasesFieldNumber = 13;
  ::google::protobuf::uint32 phases() const;
  void set_phases(::google::protobuf::uint32 value);

  // required double delay = 14;
  bool has_delay() const;
  void clear_delay();
  static const int kDelayFieldNumber = 14;
  double delay() const;
  void set_delay(double value);

  // required uint32 image_height = 15;
  bool has_image_height() const;
  void clear_image_height();
  static const int kImageHeightFieldNumber = 15;
  ::google::protobuf::uint32 image_height() const;
  void set_image_height(::google::protobuf::uint32 value);

  // required uint32 image_width = 16;
  bool has_image_width() const;
  void clear_image_width();
  static const int kImageWidthFieldNumber = 16;
  ::google::protobuf::uint32 image_width() const;
  void set_image_width(::google::protobuf::uint32 value);

  // optional uint32 thm_x = 17;
  bool has_thm_x() const;
  void clear_thm_x();
  static const int kThmXFieldNumber = 17;
  ::google::protobuf::uint32 thm_x() const;
  void set_thm_x(::google::protobuf::uint32 value);

  // optional uint32 thm_y = 18;
  bool has_thm_y() const;
  void clear_thm_y();
  static const int kThmYFieldNumber = 18;
  ::google::protobuf::uint32 thm_y() const;
  void set_thm_y(::google::protobuf::uint32 value);

  // optional uint32 thm_height = 19;
  bool has_thm_height() const;
  void clear_thm_height();
  static const int kThmHeightFieldNumber = 19;
  ::google::protobuf::uint32 thm_height() const;
  void set_thm_height(::google::protobuf::uint32 value);

  // optional uint32 thm_width = 20;
  bool has_thm_width() const;
  void clear_thm_width();
  static const int kThmWidthFieldNumber = 20;
  ::google::protobuf::uint32 thm_width() const;
  void set_thm_width(::google::protobuf::uint32 value);

  // optional uint32 thm_ref_x = 21;
  bool has_thm_ref_x() const;
  void clear_thm_ref_x();
  static const int kThmRefXFieldNumber = 21;
  ::google::protobuf::uint32 thm_ref_x() const;
  void set_thm_ref_x(::google::protobuf::uint32 value);

  // optional uint32 thm_ref_y = 22;
  bool has_thm_ref_y() const;
  void clear_thm_ref_y();
  static const int kThmRefYFieldNumber = 22;
  ::google::protobuf::uint32 thm_ref_y() const;
  void set_thm_ref_y(::google::protobuf::uint32 value);

  // optional uint32 thm_ref_height = 23;
  bool has_thm_ref_height() const;
  void clear_thm_ref_height();
  static const int kThmRefHeightFieldNumber = 23;
  ::google::protobuf::uint32 thm_ref_height() const;
  void set_thm_ref_height(::google::protobuf::uint32 value);

  // optional uint32 thm_ref_width = 24;
  bool has_thm_ref_width() const;
  void clear_thm_ref_width();
  static const int kThmRefWidthFieldNumber = 24;
  ::google::protobuf::uint32 thm_ref_width() const;
  void set_thm_ref_width(::google::protobuf::uint32 value);

  // optional uint32 te = 25;
  bool has_te() const;
  void clear_te();
  static const int kTeFieldNumber = 25;
  ::google::protobuf::uint32 te() const;
  void set_te(::google::protobuf::uint32 value);

  // optional uint32 tr = 26;
  bool has_tr() const;
  void clear_tr();
  static const int kTrFieldNumber = 26;
  ::google::protobuf::uint32 tr() const;
  void set_tr(::google::protobuf::uint32 value);

  // optional uint32 fa = 27;
  bool has_fa() const;
  void clear_fa();
  static const int kFaFieldNumber = 27;
  ::google::protobuf::uint32 fa() const;
  void set_fa(::google::protobuf::uint32 value);

  // optional uint32 freq_encoding = 28;
  bool has_freq_encoding() const;
  void clear_freq_encoding();
  static const int kFreqEncodingFieldNumber = 28;
  ::google::protobuf::uint32 freq_encoding() const;
  void set_freq_encoding(::google::protobuf::uint32 value);

  // optional uint32 phase_encoding = 29;
  bool has_phase_encoding() const;
  void clear_phase_encoding();
  static const int kPhaseEncodingFieldNumber = 29;
  ::google::protobuf::uint32 phase_encoding() const;
  void set_phase_encoding(::google::protobuf::uint32 value);

  // optional double nex = 30;
  bool has_nex() const;
  void clear_nex();
  static const int kNexFieldNumber = 30;
  double nex() const;
  void set_nex(double value);

  // optional double band_width = 31;
  bool has_band_width() const;
  void clear_band_width();
  static const int kBandWidthFieldNumber = 31;
  double band_width() const;
  void set_band_width(double value);

  // optional .FreqDirection freq_dir = 32;
  bool has_freq_dir() const;
  void clear_freq_dir();
  static const int kFreqDirFieldNumber = 32;
  ::FreqDirection freq_dir() const;
  void set_freq_dir(::FreqDirection value);

  // @@protoc_insertion_point(class_scope:GRESeq)
 private:
  inline void set_has_thm_calc();
  inline void clear_has_thm_calc();
  inline void set_has_orientation();
  inline void clear_has_orientation();
  inline void set_has_fov();
  inline void clear_has_fov();
  inline void set_has_slice_thickness();
  inline void clear_has_slice_thickness();
  inline void set_has_slice_spacing();
  inline void clear_has_slice_spacing();
  inline void set_has_start_rl();
  inline void clear_has_start_rl();
  inline void set_has_start_ap();
  inline void clear_has_start_ap();
  inline void set_has_start_is();
  inline void clear_has_start_is();
  inline void set_has_end_rl();
  inline void clear_has_end_rl();
  inline void set_has_end_ap();
  inline void clear_has_end_ap();
  inline void set_has_end_is();
  inline void clear_has_end_is();
  inline void set_has_slices();
  inline void clear_has_slices();
  inline void set_has_phases();
  inline void clear_has_phases();
  inline void set_has_delay();
  inline void clear_has_delay();
  inline void set_has_image_height();
  inline void clear_has_image_height();
  inline void set_has_image_width();
  inline void clear_has_image_width();
  inline void set_has_thm_x();
  inline void clear_has_thm_x();
  inline void set_has_thm_y();
  inline void clear_has_thm_y();
  inline void set_has_thm_height();
  inline void clear_has_thm_height();
  inline void set_has_thm_width();
  inline void clear_has_thm_width();
  inline void set_has_thm_ref_x();
  inline void clear_has_thm_ref_x();
  inline void set_has_thm_ref_y();
  inline void clear_has_thm_ref_y();
  inline void set_has_thm_ref_height();
  inline void clear_has_thm_ref_height();
  inline void set_has_thm_ref_width();
  inline void clear_has_thm_ref_width();
  inline void set_has_te();
  inline void clear_has_te();
  inline void set_has_tr();
  inline void clear_has_tr();
  inline void set_has_fa();
  inline void clear_has_fa();
  inline void set_has_freq_encoding();
  inline void clear_has_freq_encoding();
  inline void set_has_phase_encoding();
  inline void clear_has_phase_encoding();
  inline void set_has_nex();
  inline void clear_has_nex();
  inline void set_has_band_width();
  inline void clear_has_band_width();
  inline void set_has_freq_dir();
  inline void clear_has_freq_dir();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  bool thm_calc_;
  ::google::protobuf::uint32 fov_;
  double slice_thickness_;
  double slice_spacing_;
  double start_rl_;
  double start_ap_;
  double start_is_;
  double end_rl_;
  double end_ap_;
  double end_is_;
  ::google::protobuf::uint32 slices_;
  ::google::protobuf::uint32 phases_;
  double delay_;
  ::google::protobuf::uint32 image_height_;
  ::google::protobuf::uint32 image_width_;
  ::google::protobuf::uint32 thm_x_;
  ::google::protobuf::uint32 thm_y_;
  ::google::protobuf::uint32 thm_height_;
  ::google::protobuf::uint32 thm_width_;
  ::google::protobuf::uint32 thm_ref_x_;
  ::google::protobuf::uint32 thm_ref_y_;
  ::google::protobuf::uint32 thm_ref_height_;
  ::google::protobuf::uint32 thm_ref_width_;
  ::google::protobuf::uint32 te_;
  ::google::protobuf::uint32 tr_;
  ::google::protobuf::uint32 fa_;
  ::google::protobuf::uint32 freq_encoding_;
  double nex_;
  double band_width_;
  ::google::protobuf::uint32 phase_encoding_;
  int orientation_;
  int freq_dir_;
  friend void  protobuf_InitDefaults_mrgfus_2eproto_impl();
  friend void  protobuf_AddDesc_mrgfus_2eproto_impl();
  friend void protobuf_AssignDesc_mrgfus_2eproto();
  friend void protobuf_ShutdownFile_mrgfus_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<GRESeq> GRESeq_default_instance_;

// -------------------------------------------------------------------

class MRStatusQueryPb : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MRStatusQueryPb) */ {
 public:
  MRStatusQueryPb();
  virtual ~MRStatusQueryPb();

  MRStatusQueryPb(const MRStatusQueryPb& from);

  inline MRStatusQueryPb& operator=(const MRStatusQueryPb& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MRStatusQueryPb& default_instance();

  static const MRStatusQueryPb* internal_default_instance();

  void Swap(MRStatusQueryPb* other);

  // implements Message ----------------------------------------------

  inline MRStatusQueryPb* New() const { return New(NULL); }

  MRStatusQueryPb* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MRStatusQueryPb& from);
  void MergeFrom(const MRStatusQueryPb& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MRStatusQueryPb* other);
  void UnsafeMergeFrom(const MRStatusQueryPb& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MRStatusQueryPb_MRStatus MRStatus;
  static const MRStatus NORMAL =
    MRStatusQueryPb_MRStatus_NORMAL;
  static const MRStatus ABNORMAL =
    MRStatusQueryPb_MRStatus_ABNORMAL;
  static inline bool MRStatus_IsValid(int value) {
    return MRStatusQueryPb_MRStatus_IsValid(value);
  }
  static const MRStatus MRStatus_MIN =
    MRStatusQueryPb_MRStatus_MRStatus_MIN;
  static const MRStatus MRStatus_MAX =
    MRStatusQueryPb_MRStatus_MRStatus_MAX;
  static const int MRStatus_ARRAYSIZE =
    MRStatusQueryPb_MRStatus_MRStatus_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MRStatus_descriptor() {
    return MRStatusQueryPb_MRStatus_descriptor();
  }
  static inline const ::std::string& MRStatus_Name(MRStatus value) {
    return MRStatusQueryPb_MRStatus_Name(value);
  }
  static inline bool MRStatus_Parse(const ::std::string& name,
      MRStatus* value) {
    return MRStatusQueryPb_MRStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .MsgType msg_type = 1;
  bool has_msg_type() const;
  void clear_msg_type();
  static const int kMsgTypeFieldNumber = 1;
  ::MsgType msg_type() const;
  void set_msg_type(::MsgType value);

  // required string date_time = 2;
  bool has_date_time() const;
  void clear_date_time();
  static const int kDateTimeFieldNumber = 2;
  const ::std::string& date_time() const;
  void set_date_time(const ::std::string& value);
  void set_date_time(const char* value);
  void set_date_time(const char* value, size_t size);
  ::std::string* mutable_date_time();
  ::std::string* release_date_time();
  void set_allocated_date_time(::std::string* date_time);

  // optional .MRStatusQueryPb.MRStatus status = 3;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 3;
  ::MRStatusQueryPb_MRStatus status() const;
  void set_status(::MRStatusQueryPb_MRStatus value);

  // @@protoc_insertion_point(class_scope:MRStatusQueryPb)
 private:
  inline void set_has_msg_type();
  inline void clear_has_msg_type();
  inline void set_has_date_time();
  inline void clear_has_date_time();
  inline void set_has_status();
  inline void clear_has_status();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr date_time_;
  int msg_type_;
  int status_;
  friend void  protobuf_InitDefaults_mrgfus_2eproto_impl();
  friend void  protobuf_AddDesc_mrgfus_2eproto_impl();
  friend void protobuf_AssignDesc_mrgfus_2eproto();
  friend void protobuf_ShutdownFile_mrgfus_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<MRStatusQueryPb> MRStatusQueryPb_default_instance_;

// -------------------------------------------------------------------

class MRStatusNotifyPb : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MRStatusNotifyPb) */ {
 public:
  MRStatusNotifyPb();
  virtual ~MRStatusNotifyPb();

  MRStatusNotifyPb(const MRStatusNotifyPb& from);

  inline MRStatusNotifyPb& operator=(const MRStatusNotifyPb& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MRStatusNotifyPb& default_instance();

  static const MRStatusNotifyPb* internal_default_instance();

  void Swap(MRStatusNotifyPb* other);

  // implements Message ----------------------------------------------

  inline MRStatusNotifyPb* New() const { return New(NULL); }

  MRStatusNotifyPb* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MRStatusNotifyPb& from);
  void MergeFrom(const MRStatusNotifyPb& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MRStatusNotifyPb* other);
  void UnsafeMergeFrom(const MRStatusNotifyPb& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MRStatusNotifyPb_MRStatus MRStatus;
  static const MRStatus ABNORMAL =
    MRStatusNotifyPb_MRStatus_ABNORMAL;
  static const MRStatus SCAN_INTERRUPT =
    MRStatusNotifyPb_MRStatus_SCAN_INTERRUPT;
  static inline bool MRStatus_IsValid(int value) {
    return MRStatusNotifyPb_MRStatus_IsValid(value);
  }
  static const MRStatus MRStatus_MIN =
    MRStatusNotifyPb_MRStatus_MRStatus_MIN;
  static const MRStatus MRStatus_MAX =
    MRStatusNotifyPb_MRStatus_MRStatus_MAX;
  static const int MRStatus_ARRAYSIZE =
    MRStatusNotifyPb_MRStatus_MRStatus_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MRStatus_descriptor() {
    return MRStatusNotifyPb_MRStatus_descriptor();
  }
  static inline const ::std::string& MRStatus_Name(MRStatus value) {
    return MRStatusNotifyPb_MRStatus_Name(value);
  }
  static inline bool MRStatus_Parse(const ::std::string& name,
      MRStatus* value) {
    return MRStatusNotifyPb_MRStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .MsgType msg_type = 1;
  bool has_msg_type() const;
  void clear_msg_type();
  static const int kMsgTypeFieldNumber = 1;
  ::MsgType msg_type() const;
  void set_msg_type(::MsgType value);

  // optional .MRStatusNotifyPb.MRStatus status = 2;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  ::MRStatusNotifyPb_MRStatus status() const;
  void set_status(::MRStatusNotifyPb_MRStatus value);

  // @@protoc_insertion_point(class_scope:MRStatusNotifyPb)
 private:
  inline void set_has_msg_type();
  inline void clear_has_msg_type();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int msg_type_;
  int status_;
  friend void  protobuf_InitDefaults_mrgfus_2eproto_impl();
  friend void  protobuf_AddDesc_mrgfus_2eproto_impl();
  friend void protobuf_AssignDesc_mrgfus_2eproto();
  friend void protobuf_ShutdownFile_mrgfus_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<MRStatusNotifyPb> MRStatusNotifyPb_default_instance_;

// -------------------------------------------------------------------

class ManuScanPb : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ManuScanPb) */ {
 public:
  ManuScanPb();
  virtual ~ManuScanPb();

  ManuScanPb(const ManuScanPb& from);

  inline ManuScanPb& operator=(const ManuScanPb& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ManuScanPb& default_instance();

  static const ManuScanPb* internal_default_instance();

  void Swap(ManuScanPb* other);

  // implements Message ----------------------------------------------

  inline ManuScanPb* New() const { return New(NULL); }

  ManuScanPb* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ManuScanPb& from);
  void MergeFrom(const ManuScanPb& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ManuScanPb* other);
  void UnsafeMergeFrom(const ManuScanPb& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .MsgType msg_type = 1;
  bool has_msg_type() const;
  void clear_msg_type();
  static const int kMsgTypeFieldNumber = 1;
  ::MsgType msg_type() const;
  void set_msg_type(::MsgType value);

  // optional .ExecResult result = 2;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 2;
  ::ExecResult result() const;
  void set_result(::ExecResult value);

  // optional string error_msg = 3;
  bool has_error_msg() const;
  void clear_error_msg();
  static const int kErrorMsgFieldNumber = 3;
  const ::std::string& error_msg() const;
  void set_error_msg(const ::std::string& value);
  void set_error_msg(const char* value);
  void set_error_msg(const char* value, size_t size);
  ::std::string* mutable_error_msg();
  ::std::string* release_error_msg();
  void set_allocated_error_msg(::std::string* error_msg);

  // @@protoc_insertion_point(class_scope:ManuScanPb)
 private:
  inline void set_has_msg_type();
  inline void clear_has_msg_type();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_error_msg();
  inline void clear_has_error_msg();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr error_msg_;
  int msg_type_;
  int result_;
  friend void  protobuf_InitDefaults_mrgfus_2eproto_impl();
  friend void  protobuf_AddDesc_mrgfus_2eproto_impl();
  friend void protobuf_AssignDesc_mrgfus_2eproto();
  friend void protobuf_ShutdownFile_mrgfus_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<ManuScanPb> ManuScanPb_default_instance_;

// -------------------------------------------------------------------

class AutoScanPb : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:AutoScanPb) */ {
 public:
  AutoScanPb();
  virtual ~AutoScanPb();

  AutoScanPb(const AutoScanPb& from);

  inline AutoScanPb& operator=(const AutoScanPb& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AutoScanPb& default_instance();

  static const AutoScanPb* internal_default_instance();

  void Swap(AutoScanPb* other);

  // implements Message ----------------------------------------------

  inline AutoScanPb* New() const { return New(NULL); }

  AutoScanPb* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AutoScanPb& from);
  void MergeFrom(const AutoScanPb& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AutoScanPb* other);
  void UnsafeMergeFrom(const AutoScanPb& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .MsgType msg_type = 1;
  bool has_msg_type() const;
  void clear_msg_type();
  static const int kMsgTypeFieldNumber = 1;
  ::MsgType msg_type() const;
  void set_msg_type(::MsgType value);

  // optional .SeqType seq_type = 2;
  bool has_seq_type() const;
  void clear_seq_type();
  static const int kSeqTypeFieldNumber = 2;
  ::SeqType seq_type() const;
  void set_seq_type(::SeqType value);

  // optional .ExecResult result = 3;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 3;
  ::ExecResult result() const;
  void set_result(::ExecResult value);

  // optional string error_msg = 4;
  bool has_error_msg() const;
  void clear_error_msg();
  static const int kErrorMsgFieldNumber = 4;
  const ::std::string& error_msg() const;
  void set_error_msg(const ::std::string& value);
  void set_error_msg(const char* value);
  void set_error_msg(const char* value, size_t size);
  ::std::string* mutable_error_msg();
  ::std::string* release_error_msg();
  void set_allocated_error_msg(::std::string* error_msg);

  // optional .SESeq se = 5;
  bool has_se() const;
  void clear_se();
  static const int kSeFieldNumber = 5;
  const ::SESeq& se() const;
  ::SESeq* mutable_se();
  ::SESeq* release_se();
  void set_allocated_se(::SESeq* se);

  // optional .GRESeq gre = 6;
  bool has_gre() const;
  void clear_gre();
  static const int kGreFieldNumber = 6;
  const ::GRESeq& gre() const;
  ::GRESeq* mutable_gre();
  ::GRESeq* release_gre();
  void set_allocated_gre(::GRESeq* gre);

  // @@protoc_insertion_point(class_scope:AutoScanPb)
 private:
  inline void set_has_msg_type();
  inline void clear_has_msg_type();
  inline void set_has_seq_type();
  inline void clear_has_seq_type();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_error_msg();
  inline void clear_has_error_msg();
  inline void set_has_se();
  inline void clear_has_se();
  inline void set_has_gre();
  inline void clear_has_gre();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr error_msg_;
  ::SESeq* se_;
  ::GRESeq* gre_;
  int result_;
  int msg_type_;
  int seq_type_;
  friend void  protobuf_InitDefaults_mrgfus_2eproto_impl();
  friend void  protobuf_AddDesc_mrgfus_2eproto_impl();
  friend void protobuf_AssignDesc_mrgfus_2eproto();
  friend void protobuf_ShutdownFile_mrgfus_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<AutoScanPb> AutoScanPb_default_instance_;

// -------------------------------------------------------------------

class ImgXferPb : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ImgXferPb) */ {
 public:
  ImgXferPb();
  virtual ~ImgXferPb();

  ImgXferPb(const ImgXferPb& from);

  inline ImgXferPb& operator=(const ImgXferPb& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImgXferPb& default_instance();

  static const ImgXferPb* internal_default_instance();

  void Swap(ImgXferPb* other);

  // implements Message ----------------------------------------------

  inline ImgXferPb* New() const { return New(NULL); }

  ImgXferPb* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ImgXferPb& from);
  void MergeFrom(const ImgXferPb& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ImgXferPb* other);
  void UnsafeMergeFrom(const ImgXferPb& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ImgXferPb_ImageType ImageType;
  static const ImageType NON_THERM =
    ImgXferPb_ImageType_NON_THERM;
  static const ImageType THERM =
    ImgXferPb_ImageType_THERM;
  static inline bool ImageType_IsValid(int value) {
    return ImgXferPb_ImageType_IsValid(value);
  }
  static const ImageType ImageType_MIN =
    ImgXferPb_ImageType_ImageType_MIN;
  static const ImageType ImageType_MAX =
    ImgXferPb_ImageType_ImageType_MAX;
  static const int ImageType_ARRAYSIZE =
    ImgXferPb_ImageType_ImageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ImageType_descriptor() {
    return ImgXferPb_ImageType_descriptor();
  }
  static inline const ::std::string& ImageType_Name(ImageType value) {
    return ImgXferPb_ImageType_Name(value);
  }
  static inline bool ImageType_Parse(const ::std::string& name,
      ImageType* value) {
    return ImgXferPb_ImageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .ImgXferPb.ImageType image_type = 1;
  bool has_image_type() const;
  void clear_image_type();
  static const int kImageTypeFieldNumber = 1;
  ::ImgXferPb_ImageType image_type() const;
  void set_image_type(::ImgXferPb_ImageType value);

  // optional uint32 thm_x = 2;
  bool has_thm_x() const;
  void clear_thm_x();
  static const int kThmXFieldNumber = 2;
  ::google::protobuf::uint32 thm_x() const;
  void set_thm_x(::google::protobuf::uint32 value);

  // optional uint32 thm_y = 3;
  bool has_thm_y() const;
  void clear_thm_y();
  static const int kThmYFieldNumber = 3;
  ::google::protobuf::uint32 thm_y() const;
  void set_thm_y(::google::protobuf::uint32 value);

  // optional uint32 thm_height = 4;
  bool has_thm_height() const;
  void clear_thm_height();
  static const int kThmHeightFieldNumber = 4;
  ::google::protobuf::uint32 thm_height() const;
  void set_thm_height(::google::protobuf::uint32 value);

  // optional uint32 thm_width = 5;
  bool has_thm_width() const;
  void clear_thm_width();
  static const int kThmWidthFieldNumber = 5;
  ::google::protobuf::uint32 thm_width() const;
  void set_thm_width(::google::protobuf::uint32 value);

  // repeated double thm_map = 6;
  int thm_map_size() const;
  void clear_thm_map();
  static const int kThmMapFieldNumber = 6;
  double thm_map(int index) const;
  void set_thm_map(int index, double value);
  void add_thm_map(double value);
  const ::google::protobuf::RepeatedField< double >&
      thm_map() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_thm_map();

  // @@protoc_insertion_point(class_scope:ImgXferPb)
 private:
  inline void set_has_image_type();
  inline void clear_has_image_type();
  inline void set_has_thm_x();
  inline void clear_has_thm_x();
  inline void set_has_thm_y();
  inline void clear_has_thm_y();
  inline void set_has_thm_height();
  inline void clear_has_thm_height();
  inline void set_has_thm_width();
  inline void clear_has_thm_width();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< double > thm_map_;
  ::google::protobuf::uint32 thm_x_;
  ::google::protobuf::uint32 thm_y_;
  ::google::protobuf::uint32 thm_height_;
  ::google::protobuf::uint32 thm_width_;
  int image_type_;
  friend void  protobuf_InitDefaults_mrgfus_2eproto_impl();
  friend void  protobuf_AddDesc_mrgfus_2eproto_impl();
  friend void protobuf_AssignDesc_mrgfus_2eproto();
  friend void protobuf_ShutdownFile_mrgfus_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<ImgXferPb> ImgXferPb_default_instance_;

// -------------------------------------------------------------------

class MRgFUSPb : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MRgFUSPb) */ {
 public:
  MRgFUSPb();
  virtual ~MRgFUSPb();

  MRgFUSPb(const MRgFUSPb& from);

  inline MRgFUSPb& operator=(const MRgFUSPb& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MRgFUSPb& default_instance();

  static const MRgFUSPb* internal_default_instance();

  void Swap(MRgFUSPb* other);

  // implements Message ----------------------------------------------

  inline MRgFUSPb* New() const { return New(NULL); }

  MRgFUSPb* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MRgFUSPb& from);
  void MergeFrom(const MRgFUSPb& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MRgFUSPb* other);
  void UnsafeMergeFrom(const MRgFUSPb& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MRgFUSPb_ProtoCateg ProtoCateg;
  static const ProtoCateg MR_STATUS_QUERY =
    MRgFUSPb_ProtoCateg_MR_STATUS_QUERY;
  static const ProtoCateg MR_STATUS_NOTIFY =
    MRgFUSPb_ProtoCateg_MR_STATUS_NOTIFY;
  static const ProtoCateg MANU_SCAN =
    MRgFUSPb_ProtoCateg_MANU_SCAN;
  static const ProtoCateg AUTO_SCAN =
    MRgFUSPb_ProtoCateg_AUTO_SCAN;
  static const ProtoCateg IMG_XFER =
    MRgFUSPb_ProtoCateg_IMG_XFER;
  static inline bool ProtoCateg_IsValid(int value) {
    return MRgFUSPb_ProtoCateg_IsValid(value);
  }
  static const ProtoCateg ProtoCateg_MIN =
    MRgFUSPb_ProtoCateg_ProtoCateg_MIN;
  static const ProtoCateg ProtoCateg_MAX =
    MRgFUSPb_ProtoCateg_ProtoCateg_MAX;
  static const int ProtoCateg_ARRAYSIZE =
    MRgFUSPb_ProtoCateg_ProtoCateg_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ProtoCateg_descriptor() {
    return MRgFUSPb_ProtoCateg_descriptor();
  }
  static inline const ::std::string& ProtoCateg_Name(ProtoCateg value) {
    return MRgFUSPb_ProtoCateg_Name(value);
  }
  static inline bool ProtoCateg_Parse(const ::std::string& name,
      ProtoCateg* value) {
    return MRgFUSPb_ProtoCateg_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required uint32 msg_id = 1;
  bool has_msg_id() const;
  void clear_msg_id();
  static const int kMsgIdFieldNumber = 1;
  ::google::protobuf::uint32 msg_id() const;
  void set_msg_id(::google::protobuf::uint32 value);

  // required .MRgFUSPb.ProtoCateg msg_categ = 2;
  bool has_msg_categ() const;
  void clear_msg_categ();
  static const int kMsgCategFieldNumber = 2;
  ::MRgFUSPb_ProtoCateg msg_categ() const;
  void set_msg_categ(::MRgFUSPb_ProtoCateg value);

  // optional .MRStatusQueryPb mr_status_query = 3;
  bool has_mr_status_query() const;
  void clear_mr_status_query();
  static const int kMrStatusQueryFieldNumber = 3;
  const ::MRStatusQueryPb& mr_status_query() const;
  ::MRStatusQueryPb* mutable_mr_status_query();
  ::MRStatusQueryPb* release_mr_status_query();
  void set_allocated_mr_status_query(::MRStatusQueryPb* mr_status_query);

  // optional .MRStatusNotifyPb mr_status_notify = 4;
  bool has_mr_status_notify() const;
  void clear_mr_status_notify();
  static const int kMrStatusNotifyFieldNumber = 4;
  const ::MRStatusNotifyPb& mr_status_notify() const;
  ::MRStatusNotifyPb* mutable_mr_status_notify();
  ::MRStatusNotifyPb* release_mr_status_notify();
  void set_allocated_mr_status_notify(::MRStatusNotifyPb* mr_status_notify);

  // optional .ManuScanPb manu_scan = 5;
  bool has_manu_scan() const;
  void clear_manu_scan();
  static const int kManuScanFieldNumber = 5;
  const ::ManuScanPb& manu_scan() const;
  ::ManuScanPb* mutable_manu_scan();
  ::ManuScanPb* release_manu_scan();
  void set_allocated_manu_scan(::ManuScanPb* manu_scan);

  // optional .AutoScanPb auto_scan = 6;
  bool has_auto_scan() const;
  void clear_auto_scan();
  static const int kAutoScanFieldNumber = 6;
  const ::AutoScanPb& auto_scan() const;
  ::AutoScanPb* mutable_auto_scan();
  ::AutoScanPb* release_auto_scan();
  void set_allocated_auto_scan(::AutoScanPb* auto_scan);

  // optional .ImgXferPb img_xfer = 7;
  bool has_img_xfer() const;
  void clear_img_xfer();
  static const int kImgXferFieldNumber = 7;
  const ::ImgXferPb& img_xfer() const;
  ::ImgXferPb* mutable_img_xfer();
  ::ImgXferPb* release_img_xfer();
  void set_allocated_img_xfer(::ImgXferPb* img_xfer);

  // @@protoc_insertion_point(class_scope:MRgFUSPb)
 private:
  inline void set_has_msg_id();
  inline void clear_has_msg_id();
  inline void set_has_msg_categ();
  inline void clear_has_msg_categ();
  inline void set_has_mr_status_query();
  inline void clear_has_mr_status_query();
  inline void set_has_mr_status_notify();
  inline void clear_has_mr_status_notify();
  inline void set_has_manu_scan();
  inline void clear_has_manu_scan();
  inline void set_has_auto_scan();
  inline void clear_has_auto_scan();
  inline void set_has_img_xfer();
  inline void clear_has_img_xfer();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::MRStatusQueryPb* mr_status_query_;
  ::MRStatusNotifyPb* mr_status_notify_;
  ::ManuScanPb* manu_scan_;
  ::AutoScanPb* auto_scan_;
  ::ImgXferPb* img_xfer_;
  ::google::protobuf::uint32 msg_id_;
  int msg_categ_;
  friend void  protobuf_InitDefaults_mrgfus_2eproto_impl();
  friend void  protobuf_AddDesc_mrgfus_2eproto_impl();
  friend void protobuf_AssignDesc_mrgfus_2eproto();
  friend void protobuf_ShutdownFile_mrgfus_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<MRgFUSPb> MRgFUSPb_default_instance_;

// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// SESeq

// required .ScanOrient orientation = 1;
inline bool SESeq::has_orientation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SESeq::set_has_orientation() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SESeq::clear_has_orientation() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SESeq::clear_orientation() {
  orientation_ = 1;
  clear_has_orientation();
}
inline ::ScanOrient SESeq::orientation() const {
  // @@protoc_insertion_point(field_get:SESeq.orientation)
  return static_cast< ::ScanOrient >(orientation_);
}
inline void SESeq::set_orientation(::ScanOrient value) {
  assert(::ScanOrient_IsValid(value));
  set_has_orientation();
  orientation_ = value;
  // @@protoc_insertion_point(field_set:SESeq.orientation)
}

// required uint32 fov = 2;
inline bool SESeq::has_fov() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SESeq::set_has_fov() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SESeq::clear_has_fov() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SESeq::clear_fov() {
  fov_ = 0u;
  clear_has_fov();
}
inline ::google::protobuf::uint32 SESeq::fov() const {
  // @@protoc_insertion_point(field_get:SESeq.fov)
  return fov_;
}
inline void SESeq::set_fov(::google::protobuf::uint32 value) {
  set_has_fov();
  fov_ = value;
  // @@protoc_insertion_point(field_set:SESeq.fov)
}

// required double slice_thickness = 3;
inline bool SESeq::has_slice_thickness() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SESeq::set_has_slice_thickness() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SESeq::clear_has_slice_thickness() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SESeq::clear_slice_thickness() {
  slice_thickness_ = 0;
  clear_has_slice_thickness();
}
inline double SESeq::slice_thickness() const {
  // @@protoc_insertion_point(field_get:SESeq.slice_thickness)
  return slice_thickness_;
}
inline void SESeq::set_slice_thickness(double value) {
  set_has_slice_thickness();
  slice_thickness_ = value;
  // @@protoc_insertion_point(field_set:SESeq.slice_thickness)
}

// required double slice_spacing = 4;
inline bool SESeq::has_slice_spacing() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SESeq::set_has_slice_spacing() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SESeq::clear_has_slice_spacing() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SESeq::clear_slice_spacing() {
  slice_spacing_ = 0;
  clear_has_slice_spacing();
}
inline double SESeq::slice_spacing() const {
  // @@protoc_insertion_point(field_get:SESeq.slice_spacing)
  return slice_spacing_;
}
inline void SESeq::set_slice_spacing(double value) {
  set_has_slice_spacing();
  slice_spacing_ = value;
  // @@protoc_insertion_point(field_set:SESeq.slice_spacing)
}

// required double start_rl = 5;
inline bool SESeq::has_start_rl() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SESeq::set_has_start_rl() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SESeq::clear_has_start_rl() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SESeq::clear_start_rl() {
  start_rl_ = 0;
  clear_has_start_rl();
}
inline double SESeq::start_rl() const {
  // @@protoc_insertion_point(field_get:SESeq.start_rl)
  return start_rl_;
}
inline void SESeq::set_start_rl(double value) {
  set_has_start_rl();
  start_rl_ = value;
  // @@protoc_insertion_point(field_set:SESeq.start_rl)
}

// required double start_ap = 6;
inline bool SESeq::has_start_ap() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SESeq::set_has_start_ap() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SESeq::clear_has_start_ap() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SESeq::clear_start_ap() {
  start_ap_ = 0;
  clear_has_start_ap();
}
inline double SESeq::start_ap() const {
  // @@protoc_insertion_point(field_get:SESeq.start_ap)
  return start_ap_;
}
inline void SESeq::set_start_ap(double value) {
  set_has_start_ap();
  start_ap_ = value;
  // @@protoc_insertion_point(field_set:SESeq.start_ap)
}

// required double start_is = 7;
inline bool SESeq::has_start_is() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SESeq::set_has_start_is() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SESeq::clear_has_start_is() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SESeq::clear_start_is() {
  start_is_ = 0;
  clear_has_start_is();
}
inline double SESeq::start_is() const {
  // @@protoc_insertion_point(field_get:SESeq.start_is)
  return start_is_;
}
inline void SESeq::set_start_is(double value) {
  set_has_start_is();
  start_is_ = value;
  // @@protoc_insertion_point(field_set:SESeq.start_is)
}

// required double end_rl = 8;
inline bool SESeq::has_end_rl() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SESeq::set_has_end_rl() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SESeq::clear_has_end_rl() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SESeq::clear_end_rl() {
  end_rl_ = 0;
  clear_has_end_rl();
}
inline double SESeq::end_rl() const {
  // @@protoc_insertion_point(field_get:SESeq.end_rl)
  return end_rl_;
}
inline void SESeq::set_end_rl(double value) {
  set_has_end_rl();
  end_rl_ = value;
  // @@protoc_insertion_point(field_set:SESeq.end_rl)
}

// required double end_ap = 9;
inline bool SESeq::has_end_ap() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SESeq::set_has_end_ap() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SESeq::clear_has_end_ap() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SESeq::clear_end_ap() {
  end_ap_ = 0;
  clear_has_end_ap();
}
inline double SESeq::end_ap() const {
  // @@protoc_insertion_point(field_get:SESeq.end_ap)
  return end_ap_;
}
inline void SESeq::set_end_ap(double value) {
  set_has_end_ap();
  end_ap_ = value;
  // @@protoc_insertion_point(field_set:SESeq.end_ap)
}

// required double end_is = 10;
inline bool SESeq::has_end_is() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SESeq::set_has_end_is() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SESeq::clear_has_end_is() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SESeq::clear_end_is() {
  end_is_ = 0;
  clear_has_end_is();
}
inline double SESeq::end_is() const {
  // @@protoc_insertion_point(field_get:SESeq.end_is)
  return end_is_;
}
inline void SESeq::set_end_is(double value) {
  set_has_end_is();
  end_is_ = value;
  // @@protoc_insertion_point(field_set:SESeq.end_is)
}

// required uint32 slices = 11;
inline bool SESeq::has_slices() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SESeq::set_has_slices() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SESeq::clear_has_slices() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SESeq::clear_slices() {
  slices_ = 0u;
  clear_has_slices();
}
inline ::google::protobuf::uint32 SESeq::slices() const {
  // @@protoc_insertion_point(field_get:SESeq.slices)
  return slices_;
}
inline void SESeq::set_slices(::google::protobuf::uint32 value) {
  set_has_slices();
  slices_ = value;
  // @@protoc_insertion_point(field_set:SESeq.slices)
}

// required uint32 image_height = 12;
inline bool SESeq::has_image_height() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SESeq::set_has_image_height() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SESeq::clear_has_image_height() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SESeq::clear_image_height() {
  image_height_ = 0u;
  clear_has_image_height();
}
inline ::google::protobuf::uint32 SESeq::image_height() const {
  // @@protoc_insertion_point(field_get:SESeq.image_height)
  return image_height_;
}
inline void SESeq::set_image_height(::google::protobuf::uint32 value) {
  set_has_image_height();
  image_height_ = value;
  // @@protoc_insertion_point(field_set:SESeq.image_height)
}

// required uint32 image_width = 13;
inline bool SESeq::has_image_width() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SESeq::set_has_image_width() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SESeq::clear_has_image_width() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SESeq::clear_image_width() {
  image_width_ = 0u;
  clear_has_image_width();
}
inline ::google::protobuf::uint32 SESeq::image_width() const {
  // @@protoc_insertion_point(field_get:SESeq.image_width)
  return image_width_;
}
inline void SESeq::set_image_width(::google::protobuf::uint32 value) {
  set_has_image_width();
  image_width_ = value;
  // @@protoc_insertion_point(field_set:SESeq.image_width)
}

// optional uint32 te = 14;
inline bool SESeq::has_te() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SESeq::set_has_te() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SESeq::clear_has_te() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SESeq::clear_te() {
  te_ = 0u;
  clear_has_te();
}
inline ::google::protobuf::uint32 SESeq::te() const {
  // @@protoc_insertion_point(field_get:SESeq.te)
  return te_;
}
inline void SESeq::set_te(::google::protobuf::uint32 value) {
  set_has_te();
  te_ = value;
  // @@protoc_insertion_point(field_set:SESeq.te)
}

// optional uint32 tr = 15;
inline bool SESeq::has_tr() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SESeq::set_has_tr() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SESeq::clear_has_tr() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SESeq::clear_tr() {
  tr_ = 0u;
  clear_has_tr();
}
inline ::google::protobuf::uint32 SESeq::tr() const {
  // @@protoc_insertion_point(field_get:SESeq.tr)
  return tr_;
}
inline void SESeq::set_tr(::google::protobuf::uint32 value) {
  set_has_tr();
  tr_ = value;
  // @@protoc_insertion_point(field_set:SESeq.tr)
}

// optional uint32 fa = 16;
inline bool SESeq::has_fa() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void SESeq::set_has_fa() {
  _has_bits_[0] |= 0x00008000u;
}
inline void SESeq::clear_has_fa() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void SESeq::clear_fa() {
  fa_ = 0u;
  clear_has_fa();
}
inline ::google::protobuf::uint32 SESeq::fa() const {
  // @@protoc_insertion_point(field_get:SESeq.fa)
  return fa_;
}
inline void SESeq::set_fa(::google::protobuf::uint32 value) {
  set_has_fa();
  fa_ = value;
  // @@protoc_insertion_point(field_set:SESeq.fa)
}

// optional uint32 freq_encoding = 17;
inline bool SESeq::has_freq_encoding() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void SESeq::set_has_freq_encoding() {
  _has_bits_[0] |= 0x00010000u;
}
inline void SESeq::clear_has_freq_encoding() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void SESeq::clear_freq_encoding() {
  freq_encoding_ = 0u;
  clear_has_freq_encoding();
}
inline ::google::protobuf::uint32 SESeq::freq_encoding() const {
  // @@protoc_insertion_point(field_get:SESeq.freq_encoding)
  return freq_encoding_;
}
inline void SESeq::set_freq_encoding(::google::protobuf::uint32 value) {
  set_has_freq_encoding();
  freq_encoding_ = value;
  // @@protoc_insertion_point(field_set:SESeq.freq_encoding)
}

// optional uint32 phase_encoding = 18;
inline bool SESeq::has_phase_encoding() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void SESeq::set_has_phase_encoding() {
  _has_bits_[0] |= 0x00020000u;
}
inline void SESeq::clear_has_phase_encoding() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void SESeq::clear_phase_encoding() {
  phase_encoding_ = 0u;
  clear_has_phase_encoding();
}
inline ::google::protobuf::uint32 SESeq::phase_encoding() const {
  // @@protoc_insertion_point(field_get:SESeq.phase_encoding)
  return phase_encoding_;
}
inline void SESeq::set_phase_encoding(::google::protobuf::uint32 value) {
  set_has_phase_encoding();
  phase_encoding_ = value;
  // @@protoc_insertion_point(field_set:SESeq.phase_encoding)
}

// optional double nex = 19;
inline bool SESeq::has_nex() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void SESeq::set_has_nex() {
  _has_bits_[0] |= 0x00040000u;
}
inline void SESeq::clear_has_nex() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void SESeq::clear_nex() {
  nex_ = 0;
  clear_has_nex();
}
inline double SESeq::nex() const {
  // @@protoc_insertion_point(field_get:SESeq.nex)
  return nex_;
}
inline void SESeq::set_nex(double value) {
  set_has_nex();
  nex_ = value;
  // @@protoc_insertion_point(field_set:SESeq.nex)
}

// optional double band_width = 20;
inline bool SESeq::has_band_width() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void SESeq::set_has_band_width() {
  _has_bits_[0] |= 0x00080000u;
}
inline void SESeq::clear_has_band_width() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void SESeq::clear_band_width() {
  band_width_ = 0;
  clear_has_band_width();
}
inline double SESeq::band_width() const {
  // @@protoc_insertion_point(field_get:SESeq.band_width)
  return band_width_;
}
inline void SESeq::set_band_width(double value) {
  set_has_band_width();
  band_width_ = value;
  // @@protoc_insertion_point(field_set:SESeq.band_width)
}

// optional .FreqDirection freq_dir = 21;
inline bool SESeq::has_freq_dir() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void SESeq::set_has_freq_dir() {
  _has_bits_[0] |= 0x00100000u;
}
inline void SESeq::clear_has_freq_dir() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void SESeq::clear_freq_dir() {
  freq_dir_ = 1;
  clear_has_freq_dir();
}
inline ::FreqDirection SESeq::freq_dir() const {
  // @@protoc_insertion_point(field_get:SESeq.freq_dir)
  return static_cast< ::FreqDirection >(freq_dir_);
}
inline void SESeq::set_freq_dir(::FreqDirection value) {
  assert(::FreqDirection_IsValid(value));
  set_has_freq_dir();
  freq_dir_ = value;
  // @@protoc_insertion_point(field_set:SESeq.freq_dir)
}

inline const SESeq* SESeq::internal_default_instance() {
  return &SESeq_default_instance_.get();
}
// -------------------------------------------------------------------

// GRESeq

// required bool thm_calc = 1;
inline bool GRESeq::has_thm_calc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GRESeq::set_has_thm_calc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GRESeq::clear_has_thm_calc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GRESeq::clear_thm_calc() {
  thm_calc_ = false;
  clear_has_thm_calc();
}
inline bool GRESeq::thm_calc() const {
  // @@protoc_insertion_point(field_get:GRESeq.thm_calc)
  return thm_calc_;
}
inline void GRESeq::set_thm_calc(bool value) {
  set_has_thm_calc();
  thm_calc_ = value;
  // @@protoc_insertion_point(field_set:GRESeq.thm_calc)
}

// required .ScanOrient orientation = 2;
inline bool GRESeq::has_orientation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GRESeq::set_has_orientation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GRESeq::clear_has_orientation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GRESeq::clear_orientation() {
  orientation_ = 1;
  clear_has_orientation();
}
inline ::ScanOrient GRESeq::orientation() const {
  // @@protoc_insertion_point(field_get:GRESeq.orientation)
  return static_cast< ::ScanOrient >(orientation_);
}
inline void GRESeq::set_orientation(::ScanOrient value) {
  assert(::ScanOrient_IsValid(value));
  set_has_orientation();
  orientation_ = value;
  // @@protoc_insertion_point(field_set:GRESeq.orientation)
}

// required uint32 fov = 3;
inline bool GRESeq::has_fov() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GRESeq::set_has_fov() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GRESeq::clear_has_fov() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GRESeq::clear_fov() {
  fov_ = 0u;
  clear_has_fov();
}
inline ::google::protobuf::uint32 GRESeq::fov() const {
  // @@protoc_insertion_point(field_get:GRESeq.fov)
  return fov_;
}
inline void GRESeq::set_fov(::google::protobuf::uint32 value) {
  set_has_fov();
  fov_ = value;
  // @@protoc_insertion_point(field_set:GRESeq.fov)
}

// required double slice_thickness = 4;
inline bool GRESeq::has_slice_thickness() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GRESeq::set_has_slice_thickness() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GRESeq::clear_has_slice_thickness() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GRESeq::clear_slice_thickness() {
  slice_thickness_ = 0;
  clear_has_slice_thickness();
}
inline double GRESeq::slice_thickness() const {
  // @@protoc_insertion_point(field_get:GRESeq.slice_thickness)
  return slice_thickness_;
}
inline void GRESeq::set_slice_thickness(double value) {
  set_has_slice_thickness();
  slice_thickness_ = value;
  // @@protoc_insertion_point(field_set:GRESeq.slice_thickness)
}

// required double slice_spacing = 5;
inline bool GRESeq::has_slice_spacing() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GRESeq::set_has_slice_spacing() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GRESeq::clear_has_slice_spacing() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GRESeq::clear_slice_spacing() {
  slice_spacing_ = 0;
  clear_has_slice_spacing();
}
inline double GRESeq::slice_spacing() const {
  // @@protoc_insertion_point(field_get:GRESeq.slice_spacing)
  return slice_spacing_;
}
inline void GRESeq::set_slice_spacing(double value) {
  set_has_slice_spacing();
  slice_spacing_ = value;
  // @@protoc_insertion_point(field_set:GRESeq.slice_spacing)
}

// required double start_rl = 6;
inline bool GRESeq::has_start_rl() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GRESeq::set_has_start_rl() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GRESeq::clear_has_start_rl() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GRESeq::clear_start_rl() {
  start_rl_ = 0;
  clear_has_start_rl();
}
inline double GRESeq::start_rl() const {
  // @@protoc_insertion_point(field_get:GRESeq.start_rl)
  return start_rl_;
}
inline void GRESeq::set_start_rl(double value) {
  set_has_start_rl();
  start_rl_ = value;
  // @@protoc_insertion_point(field_set:GRESeq.start_rl)
}

// required double start_ap = 7;
inline bool GRESeq::has_start_ap() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GRESeq::set_has_start_ap() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GRESeq::clear_has_start_ap() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GRESeq::clear_start_ap() {
  start_ap_ = 0;
  clear_has_start_ap();
}
inline double GRESeq::start_ap() const {
  // @@protoc_insertion_point(field_get:GRESeq.start_ap)
  return start_ap_;
}
inline void GRESeq::set_start_ap(double value) {
  set_has_start_ap();
  start_ap_ = value;
  // @@protoc_insertion_point(field_set:GRESeq.start_ap)
}

// required double start_is = 8;
inline bool GRESeq::has_start_is() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GRESeq::set_has_start_is() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GRESeq::clear_has_start_is() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GRESeq::clear_start_is() {
  start_is_ = 0;
  clear_has_start_is();
}
inline double GRESeq::start_is() const {
  // @@protoc_insertion_point(field_get:GRESeq.start_is)
  return start_is_;
}
inline void GRESeq::set_start_is(double value) {
  set_has_start_is();
  start_is_ = value;
  // @@protoc_insertion_point(field_set:GRESeq.start_is)
}

// required double end_rl = 9;
inline bool GRESeq::has_end_rl() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GRESeq::set_has_end_rl() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GRESeq::clear_has_end_rl() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GRESeq::clear_end_rl() {
  end_rl_ = 0;
  clear_has_end_rl();
}
inline double GRESeq::end_rl() const {
  // @@protoc_insertion_point(field_get:GRESeq.end_rl)
  return end_rl_;
}
inline void GRESeq::set_end_rl(double value) {
  set_has_end_rl();
  end_rl_ = value;
  // @@protoc_insertion_point(field_set:GRESeq.end_rl)
}

// required double end_ap = 10;
inline bool GRESeq::has_end_ap() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GRESeq::set_has_end_ap() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GRESeq::clear_has_end_ap() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GRESeq::clear_end_ap() {
  end_ap_ = 0;
  clear_has_end_ap();
}
inline double GRESeq::end_ap() const {
  // @@protoc_insertion_point(field_get:GRESeq.end_ap)
  return end_ap_;
}
inline void GRESeq::set_end_ap(double value) {
  set_has_end_ap();
  end_ap_ = value;
  // @@protoc_insertion_point(field_set:GRESeq.end_ap)
}

// required double end_is = 11;
inline bool GRESeq::has_end_is() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GRESeq::set_has_end_is() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GRESeq::clear_has_end_is() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GRESeq::clear_end_is() {
  end_is_ = 0;
  clear_has_end_is();
}
inline double GRESeq::end_is() const {
  // @@protoc_insertion_point(field_get:GRESeq.end_is)
  return end_is_;
}
inline void GRESeq::set_end_is(double value) {
  set_has_end_is();
  end_is_ = value;
  // @@protoc_insertion_point(field_set:GRESeq.end_is)
}

// required uint32 slices = 12;
inline bool GRESeq::has_slices() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GRESeq::set_has_slices() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GRESeq::clear_has_slices() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GRESeq::clear_slices() {
  slices_ = 0u;
  clear_has_slices();
}
inline ::google::protobuf::uint32 GRESeq::slices() const {
  // @@protoc_insertion_point(field_get:GRESeq.slices)
  return slices_;
}
inline void GRESeq::set_slices(::google::protobuf::uint32 value) {
  set_has_slices();
  slices_ = value;
  // @@protoc_insertion_point(field_set:GRESeq.slices)
}

// required uint32 phases = 13;
inline bool GRESeq::has_phases() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void GRESeq::set_has_phases() {
  _has_bits_[0] |= 0x00001000u;
}
inline void GRESeq::clear_has_phases() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void GRESeq::clear_phases() {
  phases_ = 0u;
  clear_has_phases();
}
inline ::google::protobuf::uint32 GRESeq::phases() const {
  // @@protoc_insertion_point(field_get:GRESeq.phases)
  return phases_;
}
inline void GRESeq::set_phases(::google::protobuf::uint32 value) {
  set_has_phases();
  phases_ = value;
  // @@protoc_insertion_point(field_set:GRESeq.phases)
}

// required double delay = 14;
inline bool GRESeq::has_delay() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void GRESeq::set_has_delay() {
  _has_bits_[0] |= 0x00002000u;
}
inline void GRESeq::clear_has_delay() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void GRESeq::clear_delay() {
  delay_ = 0;
  clear_has_delay();
}
inline double GRESeq::delay() const {
  // @@protoc_insertion_point(field_get:GRESeq.delay)
  return delay_;
}
inline void GRESeq::set_delay(double value) {
  set_has_delay();
  delay_ = value;
  // @@protoc_insertion_point(field_set:GRESeq.delay)
}

// required uint32 image_height = 15;
inline bool GRESeq::has_image_height() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void GRESeq::set_has_image_height() {
  _has_bits_[0] |= 0x00004000u;
}
inline void GRESeq::clear_has_image_height() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void GRESeq::clear_image_height() {
  image_height_ = 0u;
  clear_has_image_height();
}
inline ::google::protobuf::uint32 GRESeq::image_height() const {
  // @@protoc_insertion_point(field_get:GRESeq.image_height)
  return image_height_;
}
inline void GRESeq::set_image_height(::google::protobuf::uint32 value) {
  set_has_image_height();
  image_height_ = value;
  // @@protoc_insertion_point(field_set:GRESeq.image_height)
}

// required uint32 image_width = 16;
inline bool GRESeq::has_image_width() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void GRESeq::set_has_image_width() {
  _has_bits_[0] |= 0x00008000u;
}
inline void GRESeq::clear_has_image_width() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void GRESeq::clear_image_width() {
  image_width_ = 0u;
  clear_has_image_width();
}
inline ::google::protobuf::uint32 GRESeq::image_width() const {
  // @@protoc_insertion_point(field_get:GRESeq.image_width)
  return image_width_;
}
inline void GRESeq::set_image_width(::google::protobuf::uint32 value) {
  set_has_image_width();
  image_width_ = value;
  // @@protoc_insertion_point(field_set:GRESeq.image_width)
}

// optional uint32 thm_x = 17;
inline bool GRESeq::has_thm_x() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void GRESeq::set_has_thm_x() {
  _has_bits_[0] |= 0x00010000u;
}
inline void GRESeq::clear_has_thm_x() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void GRESeq::clear_thm_x() {
  thm_x_ = 0u;
  clear_has_thm_x();
}
inline ::google::protobuf::uint32 GRESeq::thm_x() const {
  // @@protoc_insertion_point(field_get:GRESeq.thm_x)
  return thm_x_;
}
inline void GRESeq::set_thm_x(::google::protobuf::uint32 value) {
  set_has_thm_x();
  thm_x_ = value;
  // @@protoc_insertion_point(field_set:GRESeq.thm_x)
}

// optional uint32 thm_y = 18;
inline bool GRESeq::has_thm_y() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void GRESeq::set_has_thm_y() {
  _has_bits_[0] |= 0x00020000u;
}
inline void GRESeq::clear_has_thm_y() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void GRESeq::clear_thm_y() {
  thm_y_ = 0u;
  clear_has_thm_y();
}
inline ::google::protobuf::uint32 GRESeq::thm_y() const {
  // @@protoc_insertion_point(field_get:GRESeq.thm_y)
  return thm_y_;
}
inline void GRESeq::set_thm_y(::google::protobuf::uint32 value) {
  set_has_thm_y();
  thm_y_ = value;
  // @@protoc_insertion_point(field_set:GRESeq.thm_y)
}

// optional uint32 thm_height = 19;
inline bool GRESeq::has_thm_height() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void GRESeq::set_has_thm_height() {
  _has_bits_[0] |= 0x00040000u;
}
inline void GRESeq::clear_has_thm_height() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void GRESeq::clear_thm_height() {
  thm_height_ = 0u;
  clear_has_thm_height();
}
inline ::google::protobuf::uint32 GRESeq::thm_height() const {
  // @@protoc_insertion_point(field_get:GRESeq.thm_height)
  return thm_height_;
}
inline void GRESeq::set_thm_height(::google::protobuf::uint32 value) {
  set_has_thm_height();
  thm_height_ = value;
  // @@protoc_insertion_point(field_set:GRESeq.thm_height)
}

// optional uint32 thm_width = 20;
inline bool GRESeq::has_thm_width() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void GRESeq::set_has_thm_width() {
  _has_bits_[0] |= 0x00080000u;
}
inline void GRESeq::clear_has_thm_width() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void GRESeq::clear_thm_width() {
  thm_width_ = 0u;
  clear_has_thm_width();
}
inline ::google::protobuf::uint32 GRESeq::thm_width() const {
  // @@protoc_insertion_point(field_get:GRESeq.thm_width)
  return thm_width_;
}
inline void GRESeq::set_thm_width(::google::protobuf::uint32 value) {
  set_has_thm_width();
  thm_width_ = value;
  // @@protoc_insertion_point(field_set:GRESeq.thm_width)
}

// optional uint32 thm_ref_x = 21;
inline bool GRESeq::has_thm_ref_x() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void GRESeq::set_has_thm_ref_x() {
  _has_bits_[0] |= 0x00100000u;
}
inline void GRESeq::clear_has_thm_ref_x() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void GRESeq::clear_thm_ref_x() {
  thm_ref_x_ = 0u;
  clear_has_thm_ref_x();
}
inline ::google::protobuf::uint32 GRESeq::thm_ref_x() const {
  // @@protoc_insertion_point(field_get:GRESeq.thm_ref_x)
  return thm_ref_x_;
}
inline void GRESeq::set_thm_ref_x(::google::protobuf::uint32 value) {
  set_has_thm_ref_x();
  thm_ref_x_ = value;
  // @@protoc_insertion_point(field_set:GRESeq.thm_ref_x)
}

// optional uint32 thm_ref_y = 22;
inline bool GRESeq::has_thm_ref_y() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void GRESeq::set_has_thm_ref_y() {
  _has_bits_[0] |= 0x00200000u;
}
inline void GRESeq::clear_has_thm_ref_y() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void GRESeq::clear_thm_ref_y() {
  thm_ref_y_ = 0u;
  clear_has_thm_ref_y();
}
inline ::google::protobuf::uint32 GRESeq::thm_ref_y() const {
  // @@protoc_insertion_point(field_get:GRESeq.thm_ref_y)
  return thm_ref_y_;
}
inline void GRESeq::set_thm_ref_y(::google::protobuf::uint32 value) {
  set_has_thm_ref_y();
  thm_ref_y_ = value;
  // @@protoc_insertion_point(field_set:GRESeq.thm_ref_y)
}

// optional uint32 thm_ref_height = 23;
inline bool GRESeq::has_thm_ref_height() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void GRESeq::set_has_thm_ref_height() {
  _has_bits_[0] |= 0x00400000u;
}
inline void GRESeq::clear_has_thm_ref_height() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void GRESeq::clear_thm_ref_height() {
  thm_ref_height_ = 0u;
  clear_has_thm_ref_height();
}
inline ::google::protobuf::uint32 GRESeq::thm_ref_height() const {
  // @@protoc_insertion_point(field_get:GRESeq.thm_ref_height)
  return thm_ref_height_;
}
inline void GRESeq::set_thm_ref_height(::google::protobuf::uint32 value) {
  set_has_thm_ref_height();
  thm_ref_height_ = value;
  // @@protoc_insertion_point(field_set:GRESeq.thm_ref_height)
}

// optional uint32 thm_ref_width = 24;
inline bool GRESeq::has_thm_ref_width() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void GRESeq::set_has_thm_ref_width() {
  _has_bits_[0] |= 0x00800000u;
}
inline void GRESeq::clear_has_thm_ref_width() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void GRESeq::clear_thm_ref_width() {
  thm_ref_width_ = 0u;
  clear_has_thm_ref_width();
}
inline ::google::protobuf::uint32 GRESeq::thm_ref_width() const {
  // @@protoc_insertion_point(field_get:GRESeq.thm_ref_width)
  return thm_ref_width_;
}
inline void GRESeq::set_thm_ref_width(::google::protobuf::uint32 value) {
  set_has_thm_ref_width();
  thm_ref_width_ = value;
  // @@protoc_insertion_point(field_set:GRESeq.thm_ref_width)
}

// optional uint32 te = 25;
inline bool GRESeq::has_te() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void GRESeq::set_has_te() {
  _has_bits_[0] |= 0x01000000u;
}
inline void GRESeq::clear_has_te() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void GRESeq::clear_te() {
  te_ = 0u;
  clear_has_te();
}
inline ::google::protobuf::uint32 GRESeq::te() const {
  // @@protoc_insertion_point(field_get:GRESeq.te)
  return te_;
}
inline void GRESeq::set_te(::google::protobuf::uint32 value) {
  set_has_te();
  te_ = value;
  // @@protoc_insertion_point(field_set:GRESeq.te)
}

// optional uint32 tr = 26;
inline bool GRESeq::has_tr() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void GRESeq::set_has_tr() {
  _has_bits_[0] |= 0x02000000u;
}
inline void GRESeq::clear_has_tr() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void GRESeq::clear_tr() {
  tr_ = 0u;
  clear_has_tr();
}
inline ::google::protobuf::uint32 GRESeq::tr() const {
  // @@protoc_insertion_point(field_get:GRESeq.tr)
  return tr_;
}
inline void GRESeq::set_tr(::google::protobuf::uint32 value) {
  set_has_tr();
  tr_ = value;
  // @@protoc_insertion_point(field_set:GRESeq.tr)
}

// optional uint32 fa = 27;
inline bool GRESeq::has_fa() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void GRESeq::set_has_fa() {
  _has_bits_[0] |= 0x04000000u;
}
inline void GRESeq::clear_has_fa() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void GRESeq::clear_fa() {
  fa_ = 0u;
  clear_has_fa();
}
inline ::google::protobuf::uint32 GRESeq::fa() const {
  // @@protoc_insertion_point(field_get:GRESeq.fa)
  return fa_;
}
inline void GRESeq::set_fa(::google::protobuf::uint32 value) {
  set_has_fa();
  fa_ = value;
  // @@protoc_insertion_point(field_set:GRESeq.fa)
}

// optional uint32 freq_encoding = 28;
inline bool GRESeq::has_freq_encoding() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void GRESeq::set_has_freq_encoding() {
  _has_bits_[0] |= 0x08000000u;
}
inline void GRESeq::clear_has_freq_encoding() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void GRESeq::clear_freq_encoding() {
  freq_encoding_ = 0u;
  clear_has_freq_encoding();
}
inline ::google::protobuf::uint32 GRESeq::freq_encoding() const {
  // @@protoc_insertion_point(field_get:GRESeq.freq_encoding)
  return freq_encoding_;
}
inline void GRESeq::set_freq_encoding(::google::protobuf::uint32 value) {
  set_has_freq_encoding();
  freq_encoding_ = value;
  // @@protoc_insertion_point(field_set:GRESeq.freq_encoding)
}

// optional uint32 phase_encoding = 29;
inline bool GRESeq::has_phase_encoding() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void GRESeq::set_has_phase_encoding() {
  _has_bits_[0] |= 0x10000000u;
}
inline void GRESeq::clear_has_phase_encoding() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void GRESeq::clear_phase_encoding() {
  phase_encoding_ = 0u;
  clear_has_phase_encoding();
}
inline ::google::protobuf::uint32 GRESeq::phase_encoding() const {
  // @@protoc_insertion_point(field_get:GRESeq.phase_encoding)
  return phase_encoding_;
}
inline void GRESeq::set_phase_encoding(::google::protobuf::uint32 value) {
  set_has_phase_encoding();
  phase_encoding_ = value;
  // @@protoc_insertion_point(field_set:GRESeq.phase_encoding)
}

// optional double nex = 30;
inline bool GRESeq::has_nex() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void GRESeq::set_has_nex() {
  _has_bits_[0] |= 0x20000000u;
}
inline void GRESeq::clear_has_nex() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void GRESeq::clear_nex() {
  nex_ = 0;
  clear_has_nex();
}
inline double GRESeq::nex() const {
  // @@protoc_insertion_point(field_get:GRESeq.nex)
  return nex_;
}
inline void GRESeq::set_nex(double value) {
  set_has_nex();
  nex_ = value;
  // @@protoc_insertion_point(field_set:GRESeq.nex)
}

// optional double band_width = 31;
inline bool GRESeq::has_band_width() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void GRESeq::set_has_band_width() {
  _has_bits_[0] |= 0x40000000u;
}
inline void GRESeq::clear_has_band_width() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void GRESeq::clear_band_width() {
  band_width_ = 0;
  clear_has_band_width();
}
inline double GRESeq::band_width() const {
  // @@protoc_insertion_point(field_get:GRESeq.band_width)
  return band_width_;
}
inline void GRESeq::set_band_width(double value) {
  set_has_band_width();
  band_width_ = value;
  // @@protoc_insertion_point(field_set:GRESeq.band_width)
}

// optional .FreqDirection freq_dir = 32;
inline bool GRESeq::has_freq_dir() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void GRESeq::set_has_freq_dir() {
  _has_bits_[0] |= 0x80000000u;
}
inline void GRESeq::clear_has_freq_dir() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void GRESeq::clear_freq_dir() {
  freq_dir_ = 1;
  clear_has_freq_dir();
}
inline ::FreqDirection GRESeq::freq_dir() const {
  // @@protoc_insertion_point(field_get:GRESeq.freq_dir)
  return static_cast< ::FreqDirection >(freq_dir_);
}
inline void GRESeq::set_freq_dir(::FreqDirection value) {
  assert(::FreqDirection_IsValid(value));
  set_has_freq_dir();
  freq_dir_ = value;
  // @@protoc_insertion_point(field_set:GRESeq.freq_dir)
}

inline const GRESeq* GRESeq::internal_default_instance() {
  return &GRESeq_default_instance_.get();
}
// -------------------------------------------------------------------

// MRStatusQueryPb

// required .MsgType msg_type = 1;
inline bool MRStatusQueryPb::has_msg_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MRStatusQueryPb::set_has_msg_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MRStatusQueryPb::clear_has_msg_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MRStatusQueryPb::clear_msg_type() {
  msg_type_ = 1;
  clear_has_msg_type();
}
inline ::MsgType MRStatusQueryPb::msg_type() const {
  // @@protoc_insertion_point(field_get:MRStatusQueryPb.msg_type)
  return static_cast< ::MsgType >(msg_type_);
}
inline void MRStatusQueryPb::set_msg_type(::MsgType value) {
  assert(::MsgType_IsValid(value));
  set_has_msg_type();
  msg_type_ = value;
  // @@protoc_insertion_point(field_set:MRStatusQueryPb.msg_type)
}

// required string date_time = 2;
inline bool MRStatusQueryPb::has_date_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MRStatusQueryPb::set_has_date_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MRStatusQueryPb::clear_has_date_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MRStatusQueryPb::clear_date_time() {
  date_time_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_date_time();
}
inline const ::std::string& MRStatusQueryPb::date_time() const {
  // @@protoc_insertion_point(field_get:MRStatusQueryPb.date_time)
  return date_time_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MRStatusQueryPb::set_date_time(const ::std::string& value) {
  set_has_date_time();
  date_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MRStatusQueryPb.date_time)
}
inline void MRStatusQueryPb::set_date_time(const char* value) {
  set_has_date_time();
  date_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MRStatusQueryPb.date_time)
}
inline void MRStatusQueryPb::set_date_time(const char* value, size_t size) {
  set_has_date_time();
  date_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MRStatusQueryPb.date_time)
}
inline ::std::string* MRStatusQueryPb::mutable_date_time() {
  set_has_date_time();
  // @@protoc_insertion_point(field_mutable:MRStatusQueryPb.date_time)
  return date_time_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MRStatusQueryPb::release_date_time() {
  // @@protoc_insertion_point(field_release:MRStatusQueryPb.date_time)
  clear_has_date_time();
  return date_time_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MRStatusQueryPb::set_allocated_date_time(::std::string* date_time) {
  if (date_time != NULL) {
    set_has_date_time();
  } else {
    clear_has_date_time();
  }
  date_time_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), date_time);
  // @@protoc_insertion_point(field_set_allocated:MRStatusQueryPb.date_time)
}

// optional .MRStatusQueryPb.MRStatus status = 3;
inline bool MRStatusQueryPb::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MRStatusQueryPb::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MRStatusQueryPb::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MRStatusQueryPb::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::MRStatusQueryPb_MRStatus MRStatusQueryPb::status() const {
  // @@protoc_insertion_point(field_get:MRStatusQueryPb.status)
  return static_cast< ::MRStatusQueryPb_MRStatus >(status_);
}
inline void MRStatusQueryPb::set_status(::MRStatusQueryPb_MRStatus value) {
  assert(::MRStatusQueryPb_MRStatus_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:MRStatusQueryPb.status)
}

inline const MRStatusQueryPb* MRStatusQueryPb::internal_default_instance() {
  return &MRStatusQueryPb_default_instance_.get();
}
// -------------------------------------------------------------------

// MRStatusNotifyPb

// required .MsgType msg_type = 1;
inline bool MRStatusNotifyPb::has_msg_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MRStatusNotifyPb::set_has_msg_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MRStatusNotifyPb::clear_has_msg_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MRStatusNotifyPb::clear_msg_type() {
  msg_type_ = 1;
  clear_has_msg_type();
}
inline ::MsgType MRStatusNotifyPb::msg_type() const {
  // @@protoc_insertion_point(field_get:MRStatusNotifyPb.msg_type)
  return static_cast< ::MsgType >(msg_type_);
}
inline void MRStatusNotifyPb::set_msg_type(::MsgType value) {
  assert(::MsgType_IsValid(value));
  set_has_msg_type();
  msg_type_ = value;
  // @@protoc_insertion_point(field_set:MRStatusNotifyPb.msg_type)
}

// optional .MRStatusNotifyPb.MRStatus status = 2;
inline bool MRStatusNotifyPb::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MRStatusNotifyPb::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MRStatusNotifyPb::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MRStatusNotifyPb::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::MRStatusNotifyPb_MRStatus MRStatusNotifyPb::status() const {
  // @@protoc_insertion_point(field_get:MRStatusNotifyPb.status)
  return static_cast< ::MRStatusNotifyPb_MRStatus >(status_);
}
inline void MRStatusNotifyPb::set_status(::MRStatusNotifyPb_MRStatus value) {
  assert(::MRStatusNotifyPb_MRStatus_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:MRStatusNotifyPb.status)
}

inline const MRStatusNotifyPb* MRStatusNotifyPb::internal_default_instance() {
  return &MRStatusNotifyPb_default_instance_.get();
}
// -------------------------------------------------------------------

// ManuScanPb

// required .MsgType msg_type = 1;
inline bool ManuScanPb::has_msg_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ManuScanPb::set_has_msg_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ManuScanPb::clear_has_msg_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ManuScanPb::clear_msg_type() {
  msg_type_ = 1;
  clear_has_msg_type();
}
inline ::MsgType ManuScanPb::msg_type() const {
  // @@protoc_insertion_point(field_get:ManuScanPb.msg_type)
  return static_cast< ::MsgType >(msg_type_);
}
inline void ManuScanPb::set_msg_type(::MsgType value) {
  assert(::MsgType_IsValid(value));
  set_has_msg_type();
  msg_type_ = value;
  // @@protoc_insertion_point(field_set:ManuScanPb.msg_type)
}

// optional .ExecResult result = 2;
inline bool ManuScanPb::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ManuScanPb::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ManuScanPb::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ManuScanPb::clear_result() {
  result_ = 1;
  clear_has_result();
}
inline ::ExecResult ManuScanPb::result() const {
  // @@protoc_insertion_point(field_get:ManuScanPb.result)
  return static_cast< ::ExecResult >(result_);
}
inline void ManuScanPb::set_result(::ExecResult value) {
  assert(::ExecResult_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:ManuScanPb.result)
}

// optional string error_msg = 3;
inline bool ManuScanPb::has_error_msg() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ManuScanPb::set_has_error_msg() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ManuScanPb::clear_has_error_msg() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ManuScanPb::clear_error_msg() {
  error_msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error_msg();
}
inline const ::std::string& ManuScanPb::error_msg() const {
  // @@protoc_insertion_point(field_get:ManuScanPb.error_msg)
  return error_msg_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ManuScanPb::set_error_msg(const ::std::string& value) {
  set_has_error_msg();
  error_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ManuScanPb.error_msg)
}
inline void ManuScanPb::set_error_msg(const char* value) {
  set_has_error_msg();
  error_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ManuScanPb.error_msg)
}
inline void ManuScanPb::set_error_msg(const char* value, size_t size) {
  set_has_error_msg();
  error_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ManuScanPb.error_msg)
}
inline ::std::string* ManuScanPb::mutable_error_msg() {
  set_has_error_msg();
  // @@protoc_insertion_point(field_mutable:ManuScanPb.error_msg)
  return error_msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ManuScanPb::release_error_msg() {
  // @@protoc_insertion_point(field_release:ManuScanPb.error_msg)
  clear_has_error_msg();
  return error_msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ManuScanPb::set_allocated_error_msg(::std::string* error_msg) {
  if (error_msg != NULL) {
    set_has_error_msg();
  } else {
    clear_has_error_msg();
  }
  error_msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_msg);
  // @@protoc_insertion_point(field_set_allocated:ManuScanPb.error_msg)
}

inline const ManuScanPb* ManuScanPb::internal_default_instance() {
  return &ManuScanPb_default_instance_.get();
}
// -------------------------------------------------------------------

// AutoScanPb

// required .MsgType msg_type = 1;
inline bool AutoScanPb::has_msg_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AutoScanPb::set_has_msg_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AutoScanPb::clear_has_msg_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AutoScanPb::clear_msg_type() {
  msg_type_ = 1;
  clear_has_msg_type();
}
inline ::MsgType AutoScanPb::msg_type() const {
  // @@protoc_insertion_point(field_get:AutoScanPb.msg_type)
  return static_cast< ::MsgType >(msg_type_);
}
inline void AutoScanPb::set_msg_type(::MsgType value) {
  assert(::MsgType_IsValid(value));
  set_has_msg_type();
  msg_type_ = value;
  // @@protoc_insertion_point(field_set:AutoScanPb.msg_type)
}

// optional .SeqType seq_type = 2;
inline bool AutoScanPb::has_seq_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AutoScanPb::set_has_seq_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AutoScanPb::clear_has_seq_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AutoScanPb::clear_seq_type() {
  seq_type_ = 1;
  clear_has_seq_type();
}
inline ::SeqType AutoScanPb::seq_type() const {
  // @@protoc_insertion_point(field_get:AutoScanPb.seq_type)
  return static_cast< ::SeqType >(seq_type_);
}
inline void AutoScanPb::set_seq_type(::SeqType value) {
  assert(::SeqType_IsValid(value));
  set_has_seq_type();
  seq_type_ = value;
  // @@protoc_insertion_point(field_set:AutoScanPb.seq_type)
}

// optional .ExecResult result = 3;
inline bool AutoScanPb::has_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AutoScanPb::set_has_result() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AutoScanPb::clear_has_result() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AutoScanPb::clear_result() {
  result_ = 1;
  clear_has_result();
}
inline ::ExecResult AutoScanPb::result() const {
  // @@protoc_insertion_point(field_get:AutoScanPb.result)
  return static_cast< ::ExecResult >(result_);
}
inline void AutoScanPb::set_result(::ExecResult value) {
  assert(::ExecResult_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:AutoScanPb.result)
}

// optional string error_msg = 4;
inline bool AutoScanPb::has_error_msg() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AutoScanPb::set_has_error_msg() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AutoScanPb::clear_has_error_msg() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AutoScanPb::clear_error_msg() {
  error_msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error_msg();
}
inline const ::std::string& AutoScanPb::error_msg() const {
  // @@protoc_insertion_point(field_get:AutoScanPb.error_msg)
  return error_msg_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AutoScanPb::set_error_msg(const ::std::string& value) {
  set_has_error_msg();
  error_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AutoScanPb.error_msg)
}
inline void AutoScanPb::set_error_msg(const char* value) {
  set_has_error_msg();
  error_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AutoScanPb.error_msg)
}
inline void AutoScanPb::set_error_msg(const char* value, size_t size) {
  set_has_error_msg();
  error_msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AutoScanPb.error_msg)
}
inline ::std::string* AutoScanPb::mutable_error_msg() {
  set_has_error_msg();
  // @@protoc_insertion_point(field_mutable:AutoScanPb.error_msg)
  return error_msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AutoScanPb::release_error_msg() {
  // @@protoc_insertion_point(field_release:AutoScanPb.error_msg)
  clear_has_error_msg();
  return error_msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AutoScanPb::set_allocated_error_msg(::std::string* error_msg) {
  if (error_msg != NULL) {
    set_has_error_msg();
  } else {
    clear_has_error_msg();
  }
  error_msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_msg);
  // @@protoc_insertion_point(field_set_allocated:AutoScanPb.error_msg)
}

// optional .SESeq se = 5;
inline bool AutoScanPb::has_se() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AutoScanPb::set_has_se() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AutoScanPb::clear_has_se() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AutoScanPb::clear_se() {
  if (se_ != NULL) se_->::SESeq::Clear();
  clear_has_se();
}
inline const ::SESeq& AutoScanPb::se() const {
  // @@protoc_insertion_point(field_get:AutoScanPb.se)
  return se_ != NULL ? *se_
                         : *::SESeq::internal_default_instance();
}
inline ::SESeq* AutoScanPb::mutable_se() {
  set_has_se();
  if (se_ == NULL) {
    se_ = new ::SESeq;
  }
  // @@protoc_insertion_point(field_mutable:AutoScanPb.se)
  return se_;
}
inline ::SESeq* AutoScanPb::release_se() {
  // @@protoc_insertion_point(field_release:AutoScanPb.se)
  clear_has_se();
  ::SESeq* temp = se_;
  se_ = NULL;
  return temp;
}
inline void AutoScanPb::set_allocated_se(::SESeq* se) {
  delete se_;
  se_ = se;
  if (se) {
    set_has_se();
  } else {
    clear_has_se();
  }
  // @@protoc_insertion_point(field_set_allocated:AutoScanPb.se)
}

// optional .GRESeq gre = 6;
inline bool AutoScanPb::has_gre() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AutoScanPb::set_has_gre() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AutoScanPb::clear_has_gre() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AutoScanPb::clear_gre() {
  if (gre_ != NULL) gre_->::GRESeq::Clear();
  clear_has_gre();
}
inline const ::GRESeq& AutoScanPb::gre() const {
  // @@protoc_insertion_point(field_get:AutoScanPb.gre)
  return gre_ != NULL ? *gre_
                         : *::GRESeq::internal_default_instance();
}
inline ::GRESeq* AutoScanPb::mutable_gre() {
  set_has_gre();
  if (gre_ == NULL) {
    gre_ = new ::GRESeq;
  }
  // @@protoc_insertion_point(field_mutable:AutoScanPb.gre)
  return gre_;
}
inline ::GRESeq* AutoScanPb::release_gre() {
  // @@protoc_insertion_point(field_release:AutoScanPb.gre)
  clear_has_gre();
  ::GRESeq* temp = gre_;
  gre_ = NULL;
  return temp;
}
inline void AutoScanPb::set_allocated_gre(::GRESeq* gre) {
  delete gre_;
  gre_ = gre;
  if (gre) {
    set_has_gre();
  } else {
    clear_has_gre();
  }
  // @@protoc_insertion_point(field_set_allocated:AutoScanPb.gre)
}

inline const AutoScanPb* AutoScanPb::internal_default_instance() {
  return &AutoScanPb_default_instance_.get();
}
// -------------------------------------------------------------------

// ImgXferPb

// required .ImgXferPb.ImageType image_type = 1;
inline bool ImgXferPb::has_image_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImgXferPb::set_has_image_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImgXferPb::clear_has_image_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImgXferPb::clear_image_type() {
  image_type_ = 1;
  clear_has_image_type();
}
inline ::ImgXferPb_ImageType ImgXferPb::image_type() const {
  // @@protoc_insertion_point(field_get:ImgXferPb.image_type)
  return static_cast< ::ImgXferPb_ImageType >(image_type_);
}
inline void ImgXferPb::set_image_type(::ImgXferPb_ImageType value) {
  assert(::ImgXferPb_ImageType_IsValid(value));
  set_has_image_type();
  image_type_ = value;
  // @@protoc_insertion_point(field_set:ImgXferPb.image_type)
}

// optional uint32 thm_x = 2;
inline bool ImgXferPb::has_thm_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImgXferPb::set_has_thm_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImgXferPb::clear_has_thm_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImgXferPb::clear_thm_x() {
  thm_x_ = 0u;
  clear_has_thm_x();
}
inline ::google::protobuf::uint32 ImgXferPb::thm_x() const {
  // @@protoc_insertion_point(field_get:ImgXferPb.thm_x)
  return thm_x_;
}
inline void ImgXferPb::set_thm_x(::google::protobuf::uint32 value) {
  set_has_thm_x();
  thm_x_ = value;
  // @@protoc_insertion_point(field_set:ImgXferPb.thm_x)
}

// optional uint32 thm_y = 3;
inline bool ImgXferPb::has_thm_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ImgXferPb::set_has_thm_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ImgXferPb::clear_has_thm_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ImgXferPb::clear_thm_y() {
  thm_y_ = 0u;
  clear_has_thm_y();
}
inline ::google::protobuf::uint32 ImgXferPb::thm_y() const {
  // @@protoc_insertion_point(field_get:ImgXferPb.thm_y)
  return thm_y_;
}
inline void ImgXferPb::set_thm_y(::google::protobuf::uint32 value) {
  set_has_thm_y();
  thm_y_ = value;
  // @@protoc_insertion_point(field_set:ImgXferPb.thm_y)
}

// optional uint32 thm_height = 4;
inline bool ImgXferPb::has_thm_height() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ImgXferPb::set_has_thm_height() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ImgXferPb::clear_has_thm_height() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ImgXferPb::clear_thm_height() {
  thm_height_ = 0u;
  clear_has_thm_height();
}
inline ::google::protobuf::uint32 ImgXferPb::thm_height() const {
  // @@protoc_insertion_point(field_get:ImgXferPb.thm_height)
  return thm_height_;
}
inline void ImgXferPb::set_thm_height(::google::protobuf::uint32 value) {
  set_has_thm_height();
  thm_height_ = value;
  // @@protoc_insertion_point(field_set:ImgXferPb.thm_height)
}

// optional uint32 thm_width = 5;
inline bool ImgXferPb::has_thm_width() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ImgXferPb::set_has_thm_width() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ImgXferPb::clear_has_thm_width() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ImgXferPb::clear_thm_width() {
  thm_width_ = 0u;
  clear_has_thm_width();
}
inline ::google::protobuf::uint32 ImgXferPb::thm_width() const {
  // @@protoc_insertion_point(field_get:ImgXferPb.thm_width)
  return thm_width_;
}
inline void ImgXferPb::set_thm_width(::google::protobuf::uint32 value) {
  set_has_thm_width();
  thm_width_ = value;
  // @@protoc_insertion_point(field_set:ImgXferPb.thm_width)
}

// repeated double thm_map = 6;
inline int ImgXferPb::thm_map_size() const {
  return thm_map_.size();
}
inline void ImgXferPb::clear_thm_map() {
  thm_map_.Clear();
}
inline double ImgXferPb::thm_map(int index) const {
  // @@protoc_insertion_point(field_get:ImgXferPb.thm_map)
  return thm_map_.Get(index);
}
inline void ImgXferPb::set_thm_map(int index, double value) {
  thm_map_.Set(index, value);
  // @@protoc_insertion_point(field_set:ImgXferPb.thm_map)
}
inline void ImgXferPb::add_thm_map(double value) {
  thm_map_.Add(value);
  // @@protoc_insertion_point(field_add:ImgXferPb.thm_map)
}
inline const ::google::protobuf::RepeatedField< double >&
ImgXferPb::thm_map() const {
  // @@protoc_insertion_point(field_list:ImgXferPb.thm_map)
  return thm_map_;
}
inline ::google::protobuf::RepeatedField< double >*
ImgXferPb::mutable_thm_map() {
  // @@protoc_insertion_point(field_mutable_list:ImgXferPb.thm_map)
  return &thm_map_;
}

inline const ImgXferPb* ImgXferPb::internal_default_instance() {
  return &ImgXferPb_default_instance_.get();
}
// -------------------------------------------------------------------

// MRgFUSPb

// required uint32 msg_id = 1;
inline bool MRgFUSPb::has_msg_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MRgFUSPb::set_has_msg_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MRgFUSPb::clear_has_msg_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MRgFUSPb::clear_msg_id() {
  msg_id_ = 0u;
  clear_has_msg_id();
}
inline ::google::protobuf::uint32 MRgFUSPb::msg_id() const {
  // @@protoc_insertion_point(field_get:MRgFUSPb.msg_id)
  return msg_id_;
}
inline void MRgFUSPb::set_msg_id(::google::protobuf::uint32 value) {
  set_has_msg_id();
  msg_id_ = value;
  // @@protoc_insertion_point(field_set:MRgFUSPb.msg_id)
}

// required .MRgFUSPb.ProtoCateg msg_categ = 2;
inline bool MRgFUSPb::has_msg_categ() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MRgFUSPb::set_has_msg_categ() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MRgFUSPb::clear_has_msg_categ() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MRgFUSPb::clear_msg_categ() {
  msg_categ_ = 1;
  clear_has_msg_categ();
}
inline ::MRgFUSPb_ProtoCateg MRgFUSPb::msg_categ() const {
  // @@protoc_insertion_point(field_get:MRgFUSPb.msg_categ)
  return static_cast< ::MRgFUSPb_ProtoCateg >(msg_categ_);
}
inline void MRgFUSPb::set_msg_categ(::MRgFUSPb_ProtoCateg value) {
  assert(::MRgFUSPb_ProtoCateg_IsValid(value));
  set_has_msg_categ();
  msg_categ_ = value;
  // @@protoc_insertion_point(field_set:MRgFUSPb.msg_categ)
}

// optional .MRStatusQueryPb mr_status_query = 3;
inline bool MRgFUSPb::has_mr_status_query() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MRgFUSPb::set_has_mr_status_query() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MRgFUSPb::clear_has_mr_status_query() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MRgFUSPb::clear_mr_status_query() {
  if (mr_status_query_ != NULL) mr_status_query_->::MRStatusQueryPb::Clear();
  clear_has_mr_status_query();
}
inline const ::MRStatusQueryPb& MRgFUSPb::mr_status_query() const {
  // @@protoc_insertion_point(field_get:MRgFUSPb.mr_status_query)
  return mr_status_query_ != NULL ? *mr_status_query_
                         : *::MRStatusQueryPb::internal_default_instance();
}
inline ::MRStatusQueryPb* MRgFUSPb::mutable_mr_status_query() {
  set_has_mr_status_query();
  if (mr_status_query_ == NULL) {
    mr_status_query_ = new ::MRStatusQueryPb;
  }
  // @@protoc_insertion_point(field_mutable:MRgFUSPb.mr_status_query)
  return mr_status_query_;
}
inline ::MRStatusQueryPb* MRgFUSPb::release_mr_status_query() {
  // @@protoc_insertion_point(field_release:MRgFUSPb.mr_status_query)
  clear_has_mr_status_query();
  ::MRStatusQueryPb* temp = mr_status_query_;
  mr_status_query_ = NULL;
  return temp;
}
inline void MRgFUSPb::set_allocated_mr_status_query(::MRStatusQueryPb* mr_status_query) {
  delete mr_status_query_;
  mr_status_query_ = mr_status_query;
  if (mr_status_query) {
    set_has_mr_status_query();
  } else {
    clear_has_mr_status_query();
  }
  // @@protoc_insertion_point(field_set_allocated:MRgFUSPb.mr_status_query)
}

// optional .MRStatusNotifyPb mr_status_notify = 4;
inline bool MRgFUSPb::has_mr_status_notify() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MRgFUSPb::set_has_mr_status_notify() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MRgFUSPb::clear_has_mr_status_notify() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MRgFUSPb::clear_mr_status_notify() {
  if (mr_status_notify_ != NULL) mr_status_notify_->::MRStatusNotifyPb::Clear();
  clear_has_mr_status_notify();
}
inline const ::MRStatusNotifyPb& MRgFUSPb::mr_status_notify() const {
  // @@protoc_insertion_point(field_get:MRgFUSPb.mr_status_notify)
  return mr_status_notify_ != NULL ? *mr_status_notify_
                         : *::MRStatusNotifyPb::internal_default_instance();
}
inline ::MRStatusNotifyPb* MRgFUSPb::mutable_mr_status_notify() {
  set_has_mr_status_notify();
  if (mr_status_notify_ == NULL) {
    mr_status_notify_ = new ::MRStatusNotifyPb;
  }
  // @@protoc_insertion_point(field_mutable:MRgFUSPb.mr_status_notify)
  return mr_status_notify_;
}
inline ::MRStatusNotifyPb* MRgFUSPb::release_mr_status_notify() {
  // @@protoc_insertion_point(field_release:MRgFUSPb.mr_status_notify)
  clear_has_mr_status_notify();
  ::MRStatusNotifyPb* temp = mr_status_notify_;
  mr_status_notify_ = NULL;
  return temp;
}
inline void MRgFUSPb::set_allocated_mr_status_notify(::MRStatusNotifyPb* mr_status_notify) {
  delete mr_status_notify_;
  mr_status_notify_ = mr_status_notify;
  if (mr_status_notify) {
    set_has_mr_status_notify();
  } else {
    clear_has_mr_status_notify();
  }
  // @@protoc_insertion_point(field_set_allocated:MRgFUSPb.mr_status_notify)
}

// optional .ManuScanPb manu_scan = 5;
inline bool MRgFUSPb::has_manu_scan() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MRgFUSPb::set_has_manu_scan() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MRgFUSPb::clear_has_manu_scan() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MRgFUSPb::clear_manu_scan() {
  if (manu_scan_ != NULL) manu_scan_->::ManuScanPb::Clear();
  clear_has_manu_scan();
}
inline const ::ManuScanPb& MRgFUSPb::manu_scan() const {
  // @@protoc_insertion_point(field_get:MRgFUSPb.manu_scan)
  return manu_scan_ != NULL ? *manu_scan_
                         : *::ManuScanPb::internal_default_instance();
}
inline ::ManuScanPb* MRgFUSPb::mutable_manu_scan() {
  set_has_manu_scan();
  if (manu_scan_ == NULL) {
    manu_scan_ = new ::ManuScanPb;
  }
  // @@protoc_insertion_point(field_mutable:MRgFUSPb.manu_scan)
  return manu_scan_;
}
inline ::ManuScanPb* MRgFUSPb::release_manu_scan() {
  // @@protoc_insertion_point(field_release:MRgFUSPb.manu_scan)
  clear_has_manu_scan();
  ::ManuScanPb* temp = manu_scan_;
  manu_scan_ = NULL;
  return temp;
}
inline void MRgFUSPb::set_allocated_manu_scan(::ManuScanPb* manu_scan) {
  delete manu_scan_;
  manu_scan_ = manu_scan;
  if (manu_scan) {
    set_has_manu_scan();
  } else {
    clear_has_manu_scan();
  }
  // @@protoc_insertion_point(field_set_allocated:MRgFUSPb.manu_scan)
}

// optional .AutoScanPb auto_scan = 6;
inline bool MRgFUSPb::has_auto_scan() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MRgFUSPb::set_has_auto_scan() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MRgFUSPb::clear_has_auto_scan() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MRgFUSPb::clear_auto_scan() {
  if (auto_scan_ != NULL) auto_scan_->::AutoScanPb::Clear();
  clear_has_auto_scan();
}
inline const ::AutoScanPb& MRgFUSPb::auto_scan() const {
  // @@protoc_insertion_point(field_get:MRgFUSPb.auto_scan)
  return auto_scan_ != NULL ? *auto_scan_
                         : *::AutoScanPb::internal_default_instance();
}
inline ::AutoScanPb* MRgFUSPb::mutable_auto_scan() {
  set_has_auto_scan();
  if (auto_scan_ == NULL) {
    auto_scan_ = new ::AutoScanPb;
  }
  // @@protoc_insertion_point(field_mutable:MRgFUSPb.auto_scan)
  return auto_scan_;
}
inline ::AutoScanPb* MRgFUSPb::release_auto_scan() {
  // @@protoc_insertion_point(field_release:MRgFUSPb.auto_scan)
  clear_has_auto_scan();
  ::AutoScanPb* temp = auto_scan_;
  auto_scan_ = NULL;
  return temp;
}
inline void MRgFUSPb::set_allocated_auto_scan(::AutoScanPb* auto_scan) {
  delete auto_scan_;
  auto_scan_ = auto_scan;
  if (auto_scan) {
    set_has_auto_scan();
  } else {
    clear_has_auto_scan();
  }
  // @@protoc_insertion_point(field_set_allocated:MRgFUSPb.auto_scan)
}

// optional .ImgXferPb img_xfer = 7;
inline bool MRgFUSPb::has_img_xfer() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MRgFUSPb::set_has_img_xfer() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MRgFUSPb::clear_has_img_xfer() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MRgFUSPb::clear_img_xfer() {
  if (img_xfer_ != NULL) img_xfer_->::ImgXferPb::Clear();
  clear_has_img_xfer();
}
inline const ::ImgXferPb& MRgFUSPb::img_xfer() const {
  // @@protoc_insertion_point(field_get:MRgFUSPb.img_xfer)
  return img_xfer_ != NULL ? *img_xfer_
                         : *::ImgXferPb::internal_default_instance();
}
inline ::ImgXferPb* MRgFUSPb::mutable_img_xfer() {
  set_has_img_xfer();
  if (img_xfer_ == NULL) {
    img_xfer_ = new ::ImgXferPb;
  }
  // @@protoc_insertion_point(field_mutable:MRgFUSPb.img_xfer)
  return img_xfer_;
}
inline ::ImgXferPb* MRgFUSPb::release_img_xfer() {
  // @@protoc_insertion_point(field_release:MRgFUSPb.img_xfer)
  clear_has_img_xfer();
  ::ImgXferPb* temp = img_xfer_;
  img_xfer_ = NULL;
  return temp;
}
inline void MRgFUSPb::set_allocated_img_xfer(::ImgXferPb* img_xfer) {
  delete img_xfer_;
  img_xfer_ = img_xfer;
  if (img_xfer) {
    set_has_img_xfer();
  } else {
    clear_has_img_xfer();
  }
  // @@protoc_insertion_point(field_set_allocated:MRgFUSPb.img_xfer)
}

inline const MRgFUSPb* MRgFUSPb::internal_default_instance() {
  return &MRgFUSPb_default_instance_.get();
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::MRStatusQueryPb_MRStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MRStatusQueryPb_MRStatus>() {
  return ::MRStatusQueryPb_MRStatus_descriptor();
}
template <> struct is_proto_enum< ::MRStatusNotifyPb_MRStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MRStatusNotifyPb_MRStatus>() {
  return ::MRStatusNotifyPb_MRStatus_descriptor();
}
template <> struct is_proto_enum< ::ImgXferPb_ImageType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ImgXferPb_ImageType>() {
  return ::ImgXferPb_ImageType_descriptor();
}
template <> struct is_proto_enum< ::MRgFUSPb_ProtoCateg> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MRgFUSPb_ProtoCateg>() {
  return ::MRgFUSPb_ProtoCateg_descriptor();
}
template <> struct is_proto_enum< ::MsgType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MsgType>() {
  return ::MsgType_descriptor();
}
template <> struct is_proto_enum< ::ExecResult> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ExecResult>() {
  return ::ExecResult_descriptor();
}
template <> struct is_proto_enum< ::SeqType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SeqType>() {
  return ::SeqType_descriptor();
}
template <> struct is_proto_enum< ::ScanOrient> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ScanOrient>() {
  return ::ScanOrient_descriptor();
}
template <> struct is_proto_enum< ::FreqDirection> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::FreqDirection>() {
  return ::FreqDirection_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_mrgfus_2eproto__INCLUDED
